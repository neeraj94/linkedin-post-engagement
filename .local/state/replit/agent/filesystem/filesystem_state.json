{"file_contents":{"content.js":{"content":"// Content script for LinkedIn post automation\nlet isProcessing = false;\n\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'processPost') {\n        console.log('Content script received processPost message:', message);\n        processLinkedInPost(message.comment, message.index);\n    }\n});\n\nasync function processLinkedInPost(commentText, index) {\n    if (isProcessing) {\n        console.log('Already processing, skipping...');\n        return;\n    }\n    \n    isProcessing = true;\n    console.log('Starting to process LinkedIn post...');\n    \n    try {\n        // Wait for page to load - try multiple selectors for different LinkedIn page types\n        console.log('Waiting for page to load...');\n        await waitForLinkedInPage();\n        \n        let status = '';\n        \n        // Try to like the post\n        console.log('Attempting to like post...');\n        const likeResult = await tryLikePost();\n        status += likeResult;\n        console.log('Like result:', likeResult);\n        \n        // Try to comment on the post\n        console.log('Attempting to comment on post...');\n        const commentResult = await tryCommentPost(commentText);\n        status += commentResult;\n        console.log('Comment result:', commentResult);\n        \n        // Send result back to background script\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: status || 'completed'\n        });\n        \n    } catch (error) {\n        console.error('Error processing post:', error);\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: 'error: ' + error.message\n        });\n    } finally {\n        isProcessing = false;\n    }\n}\n\nasync function waitForLinkedInPage() {\n    // Try multiple selectors for different LinkedIn page types\n    const pageSelectors = [\n        '[data-test-id=\"feed-shared-update-v2\"]', // Feed posts\n        '.feed-shared-update-v2',                 // Alternative feed posts\n        '.share-update-v2',                       // Individual posts\n        '.single-post-view',                      // Single post page\n        '[data-urn*=\"activity:\"]',                // Activity containers\n        '.activity-content',                      // Activity content\n        '.social-action-bar',                     // Action bar with like/comment buttons\n        'main[role=\"main\"]'                       // Main content area\n    ];\n    \n    console.log('Trying to find LinkedIn page elements...');\n    \n    for (const selector of pageSelectors) {\n        try {\n            console.log('Trying selector:', selector);\n            await waitForElement(selector, 2000);\n            console.log('Found element with selector:', selector);\n            return;\n        } catch (e) {\n            console.log('Selector not found:', selector);\n        }\n    }\n    \n    // If no specific selectors work, just wait a bit for page to settle\n    console.log('No specific LinkedIn elements found, waiting for page to settle...');\n    await sleep(3000);\n}\n\nasync function tryLikePost() {\n    try {\n        // Comprehensive like button selectors for current LinkedIn\n        const likeSelectors = [\n            // General like button patterns\n            'button[aria-label*=\"Like\"]',\n            'button[aria-label*=\"like\"]', \n            'button[aria-label*=\"React Like\"]',\n            '[data-control-name=\"like\"]',\n            \n            // Specific LinkedIn patterns\n            '.reactions-menu button[aria-label*=\"Like\"]',\n            '.social-actions-bar button[aria-label*=\"Like\"]',\n            '.social-action-bar button[aria-label*=\"Like\"]',\n            'button[data-test-id=\"like-button\"]',\n            'button.artdeco-button[aria-label*=\"Like\"]',\n            \n            // SVG-based like buttons\n            'button[aria-label*=\"Like\"] svg',\n            'button:has(svg[data-test-id=\"thumbs-up-outline-medium\"])',\n            'button:has(svg[data-test-id=\"thumbs-up-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Like\"]',\n            'button[title*=\"like\"]',\n            '.like-button',\n            '[data-tracking-control-name*=\"like\"]'\n        ];\n        \n        console.log('Searching for like button...');\n        let likeButton = null;\n        \n        for (const selector of likeSelectors) {\n            try {\n                console.log('Trying like selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaPressed = button.getAttribute('aria-pressed');\n                    const ariaLabel = button.getAttribute('aria-label');\n                    \n                    console.log('Button details:', {\n                        selector,\n                        ariaLabel,\n                        ariaPressed,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    // Check if this is a like button that hasn't been pressed\n                    if (ariaPressed === 'false' || (!ariaPressed && ariaLabel && ariaLabel.toLowerCase().includes('like'))) {\n                        likeButton = button;\n                        console.log('Found like button:', button);\n                        break;\n                    }\n                }\n                if (likeButton) break;\n            } catch (e) {\n                console.log('Error with selector:', selector, e);\n            }\n        }\n        \n        if (likeButton) {\n            // Double check if already liked\n            const ariaPressed = likeButton.getAttribute('aria-pressed');\n            const ariaLabel = likeButton.getAttribute('aria-label');\n            \n            if (ariaPressed === 'true' || (ariaLabel && ariaLabel.toLowerCase().includes('unlike'))) {\n                console.log('Post already liked');\n                return 'already liked, ';\n            }\n            \n            console.log('Clicking like button...');\n            likeButton.click();\n            await sleep(1500); // Wait for like to register\n            console.log('Like button clicked successfully');\n            return 'liked, ';\n        } else {\n            console.log('Like button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 10); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'like button not found, ';\n        }\n    } catch (error) {\n        console.error('Error liking post:', error);\n        return 'like failed: ' + error.message + ', ';\n    }\n}\n\nasync function tryCommentPost(commentText) {\n    try {\n        // Comprehensive comment button selectors for current LinkedIn\n        const commentSelectors = [\n            // Primary comment button patterns\n            'button[aria-label*=\"Comment\"]',\n            'button[aria-label*=\"comment\"]',\n            'button[aria-label*=\"Add a comment\"]',\n            '[data-control-name=\"comment\"]',\n            \n            // Specific LinkedIn patterns\n            '.social-actions-bar button[aria-label*=\"Comment\"]',\n            '.social-action-bar button[aria-label*=\"Comment\"]',\n            'button[data-test-id=\"comment-button\"]',\n            'button.artdeco-button[aria-label*=\"Comment\"]',\n            \n            // SVG-based comment buttons\n            'button:has(svg[data-test-id=\"comment-outline-medium\"])',\n            'button:has(svg[data-test-id=\"comment-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Comment\"]',\n            '.comment-button',\n            '[data-tracking-control-name*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment button...');\n        let commentButton = null;\n        \n        for (const selector of commentSelectors) {\n            try {\n                console.log('Trying comment selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    console.log('Comment button details:', {\n                        selector,\n                        ariaLabel,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    if (ariaLabel && ariaLabel.toLowerCase().includes('comment')) {\n                        commentButton = button;\n                        console.log('Found comment button:', button);\n                        break;\n                    }\n                }\n                if (commentButton) break;\n            } catch (e) {\n                console.log('Error with comment selector:', selector, e);\n            }\n        }\n        \n        if (!commentButton) {\n            console.log('Comment button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 15); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'comment button not found';\n        }\n        \n        console.log('Clicking comment button...');\n        commentButton.click();\n        await sleep(2000); // Wait for comment box to appear\n        \n        // Look for comment input with comprehensive selectors\n        const commentInputSelectors = [\n            // Primary comment input patterns\n            '[contenteditable=\"true\"][aria-label*=\"comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"Add a comment\"]',\n            \n            // LinkedIn specific patterns\n            '.ql-editor[contenteditable=\"true\"]',\n            '[role=\"textbox\"][contenteditable=\"true\"]',\n            '.comments-comment-texteditor [contenteditable=\"true\"]',\n            '.comment-compose-form [contenteditable=\"true\"]',\n            \n            // Fallback patterns\n            'div[contenteditable=\"true\"]',\n            '[data-placeholder*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment input...');\n        let commentInput = null;\n        \n        for (const selector of commentInputSelectors) {\n            try {\n                console.log('Trying comment input selector:', selector);\n                const inputs = document.querySelectorAll(selector);\n                console.log(`Found ${inputs.length} comment inputs for selector:`, selector);\n                \n                for (const input of inputs) {\n                    if (input.offsetHeight > 0 && input.offsetWidth > 0) { // Check if visible\n                        commentInput = input;\n                        console.log('Found visible comment input:', input);\n                        break;\n                    }\n                }\n                if (commentInput) break;\n            } catch (e) {\n                console.log('Error with comment input selector:', selector, e);\n            }\n        }\n        \n        if (!commentInput) {\n            console.log('Comment input not found. Available contenteditable elements:');\n            const editables = document.querySelectorAll('[contenteditable=\"true\"]');\n            for (let i = 0; i < Math.min(editables.length, 10); i++) {\n                const elem = editables[i];\n                console.log(`Editable ${i}:`, {\n                    ariaLabel: elem.getAttribute('aria-label'),\n                    placeholder: elem.getAttribute('placeholder'),\n                    className: elem.className,\n                    visible: elem.offsetHeight > 0 && elem.offsetWidth > 0\n                });\n            }\n            return 'comment input not found';\n        }\n        \n        // Check if we already commented\n        console.log('Checking for existing comments...');\n        const existingComments = document.querySelectorAll('[data-test-id=\"comment\"], .comment-item, .comments-comment-item');\n        const shortCommentText = commentText.substring(0, 50);\n        for (const comment of existingComments) {\n            if (comment.textContent.includes(shortCommentText)) {\n                console.log('Already commented with this text');\n                return 'already commented';\n            }\n        }\n        \n        // Focus and add the comment\n        console.log('Adding comment text...');\n        commentInput.focus();\n        \n        // Clear existing content and add new comment\n        commentInput.innerHTML = '';\n        commentInput.textContent = commentText;\n        \n        // Trigger multiple events to ensure LinkedIn recognizes the input\n        const events = ['input', 'keyup', 'change'];\n        for (const eventType of events) {\n            const event = new Event(eventType, { bubbles: true });\n            commentInput.dispatchEvent(event);\n        }\n        \n        await sleep(1500);\n        \n        // Look for submit/post button\n        const submitSelectors = [\n            'button[aria-label*=\"Post comment\"]',\n            'button[aria-label*=\"Post\"]',\n            'button[data-control-name=\"comment.post\"]',\n            'button[type=\"submit\"]',\n            '.comment-compose-form button[type=\"submit\"]',\n            '.comments-comment-box button[aria-label*=\"Post\"]',\n            'button:has(span:contains(\"Post\"))',\n            'button.artdeco-button--primary'\n        ];\n        \n        console.log('Searching for submit button...');\n        let submitButton = null;\n        \n        for (const selector of submitSelectors) {\n            try {\n                console.log('Trying submit selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    const textContent = button.textContent.toLowerCase();\n                    \n                    if ((ariaLabel && ariaLabel.toLowerCase().includes('post')) || \n                        textContent.includes('post') || \n                        textContent.includes('submit')) {\n                        submitButton = button;\n                        console.log('Found submit button:', button);\n                        break;\n                    }\n                }\n                if (submitButton) break;\n            } catch (e) {\n                console.log('Error with submit selector:', selector, e);\n            }\n        }\n        \n        if (submitButton && !submitButton.disabled && !submitButton.getAttribute('disabled')) {\n            console.log('Clicking submit button...');\n            submitButton.click();\n            await sleep(3000); // Wait for comment to post\n            return 'commented';\n        } else {\n            console.log('Submit button not found or disabled. Available buttons near comment:');\n            const nearbyButtons = commentInput.closest('form, .comment-compose-form, .comments-comment-box')?.querySelectorAll('button') || [];\n            for (let i = 0; i < nearbyButtons.length; i++) {\n                const btn = nearbyButtons[i];\n                console.log(`Nearby button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    disabled: btn.disabled,\n                    className: btn.className\n                });\n            }\n            return 'submit button not found or disabled';\n        }\n    } catch (error) {\n        console.error('Error commenting on post:', error);\n        return 'comment failed: ' + error.message;\n    }\n}\n\nfunction waitForElement(selector, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const element = document.querySelector(selector);\n        if (element) {\n            resolve(element);\n            return;\n        }\n        \n        const observer = new MutationObserver((mutations) => {\n            const element = document.querySelector(selector);\n            if (element) {\n                observer.disconnect();\n                resolve(element);\n            }\n        });\n        \n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n        \n        setTimeout(() => {\n            observer.disconnect();\n            reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n        }, timeout);\n    });\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Log when content script loads\nconsole.log('LinkedIn Auto Commenter content script loaded');","size_bytes":17607},"replit.md":{"content":"# LinkedIn Auto Commenter Chrome Extension\n\n## Overview\n\nThis project is a Chrome browser extension that automates interactions with LinkedIn posts. The extension allows users to automatically like and comment on multiple LinkedIn posts by providing a list of post URLs and a comment template. It features a user-friendly popup interface for configuration, background processing for automation management, and content script injection for DOM manipulation on LinkedIn pages. The project includes a simple Python HTTP server for distributing the extension files during development and testing.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\nThe extension uses Chrome's Manifest V3 architecture with a popup-based user interface. The popup (popup.html/popup.js) provides a clean form interface where users can input their comment text and LinkedIn post URLs. The interface includes real-time status updates, progress tracking, and persistent storage of user inputs using Chrome's sync storage API.\n\n### Extension Architecture\nThe system follows Chrome extension best practices with clear separation of concerns:\n\n- **Background Service Worker** (background.js): Manages the automation workflow, maintains state across browser sessions, and coordinates between different extension components. Uses Chrome's storage API for persistence and handles tab management for sequential post processing.\n\n- **Content Scripts** (content.js): Injected into LinkedIn pages to perform DOM manipulation. Handles the actual liking and commenting actions by finding and interacting with LinkedIn's UI elements. Implements robust element waiting and error handling for reliable automation.\n\n- **Popup Interface** (popup.js): Provides user controls and real-time feedback. Manages user input validation, displays automation progress, and communicates with the background worker.\n\n### Automation Flow\nThe extension implements a sequential processing pattern where posts are opened one at a time in controlled tabs. This approach ensures reliable execution and reduces the risk of being flagged by LinkedIn's anti-automation systems. The workflow includes validation of already-liked/commented posts to avoid duplicate actions.\n\n### State Management\nUses Chrome's storage API for state persistence, ensuring the automation can resume after browser restarts or extension updates. The state includes current automation status, progress tracking, and user preferences.\n\n## External Dependencies\n\n### Chrome APIs\n- **chrome.storage**: For persistent data storage and user preferences\n- **chrome.tabs**: For tab management and URL navigation during automation\n- **chrome.runtime**: For inter-component messaging and extension lifecycle management\n- **chrome.alarms**: For timing and scheduling automation tasks\n- **chrome.notifications**: For user notifications and status updates\n\n### Target Platform\n- **LinkedIn.com**: The extension specifically targets LinkedIn's web interface and relies on LinkedIn's DOM structure for post interaction. The content scripts are designed to work with LinkedIn's current UI patterns for like buttons, comment sections, and post identification.\n\n### Development Server\n- **Python HTTP Server**: A simple development server (server.py) that serves extension files with proper CORS headers for testing and distribution during development phases.\n\n### Browser Compatibility\nDesigned for Chrome browsers supporting Manifest V3, with permissions configured for LinkedIn domain access and necessary browser APIs for automation functionality.","size_bytes":3626},"server.py":{"content":"#!/usr/bin/env python3\nimport http.server\nimport socketserver\nimport os\n\nPORT = 5000\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache')\n        super().end_headers()\n\nif __name__ == \"__main__\":\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    with socketserver.TCPServer((\"0.0.0.0\", PORT), MyHTTPRequestHandler) as httpd:\n        print(f\"Serving Chrome extension files at http://0.0.0.0:{PORT}\")\n        print(f\"Extension files available for download and installation\")\n        httpd.serve_forever()","size_bytes":826},"chrome-extension/background.js":{"content":"// Use chrome.storage to persist state across service worker suspensions\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'startAutomation') {\n        startAutomation(message.comment, message.urls, message.minDelay, message.maxDelay);\n    } else if (message.action === 'stopAutomation') {\n        stopAutomation();\n    } else if (message.action === 'postProcessed') {\n        handlePostProcessed(message);\n    } else if (message.action === 'getStatus') {\n        getAutomationStatus(sendResponse);\n        return true; // Keep message channel open for async response\n    }\n});\n\nasync function startAutomation(comment, urls, minDelay = 2, maxDelay = 5) {\n    const state = await getStoredState();\n    if (state.isRunning) {\n        return;\n    }\n\n    const newState = {\n        isRunning: true,\n        comment: comment,\n        urls: urls,\n        currentIndex: 0,\n        tabId: null,\n        startTime: Date.now(),\n        minDelay: minDelay,\n        maxDelay: maxDelay,\n        activityLog: []\n    };\n\n    await saveState(newState);\n    await logMessage(`Starting automation with ${urls.length} URLs and ${minDelay}-${maxDelay}s delay`, 'success');\n    \n    try {\n        await processNextUrl();\n    } catch (error) {\n        console.error('Automation error:', error);\n        await notifyError('Automation error: ' + error.message);\n        await logMessage('Automation error: ' + error.message, 'error');\n        await stopAutomation();\n    }\n}\n\nasync function processNextUrl() {\n    const state = await getStoredState();\n    \n    if (!state.isRunning || state.currentIndex >= state.urls.length) {\n        // All URLs processed\n        await notifyProgress('Automation completed successfully!');\n        await notifyPopup({action: 'automationComplete'});\n        await stopAutomation();\n        return;\n    }\n\n    const currentUrl = state.urls[state.currentIndex];\n    \n    await notifyProgress(`Processing ${state.currentIndex + 1}/${state.urls.length}: opening post...`);\n    await notifyPopup({\n        action: 'updateProgress',\n        index: state.currentIndex,\n        status: 'opening post...'\n    });\n\n    // Create or update tab with the LinkedIn post\n    try {\n        let tabId = state.tabId;\n        \n        if (tabId) {\n            try {\n                await chrome.tabs.update(tabId, {url: currentUrl, active: true});\n            } catch (error) {\n                // Tab might have been closed, create a new one\n                const tab = await chrome.tabs.create({url: currentUrl, active: true});\n                tabId = tab.id;\n                await saveState({...state, tabId: tabId});\n            }\n        } else {\n            const tab = await chrome.tabs.create({url: currentUrl, active: true});\n            tabId = tab.id;\n            await saveState({...state, tabId: tabId});\n        }\n\n        // Use chrome.alarms instead of setTimeout to survive service worker suspension\n        chrome.alarms.clear('processPost');\n        chrome.alarms.create('processPost', {delayInMinutes: 0.05}); // 3 seconds\n        \n    } catch (error) {\n        console.error('Error creating tab:', error);\n        await notifyError('Failed to open LinkedIn post: ' + error.message);\n        await stopAutomation();\n    }\n}\n\nasync function handlePostProcessed(message) {\n    const state = await getStoredState();\n    if (!state.isRunning) return;\n\n    await notifyProgress(`Post ${state.currentIndex + 1}: ${message.status}`);\n    await notifyPopup({\n        action: 'updateProgress',\n        index: state.currentIndex,\n        status: message.status\n    });\n\n    const newIndex = state.currentIndex + 1;\n    await saveState({...state, currentIndex: newIndex});\n    \n    // Use chrome.alarms for reliable timing with random delay\n    const randomDelay = getRandomDelay(state.minDelay || 2, state.maxDelay || 5);\n    await logMessage(`Waiting ${randomDelay}s before next post...`, 'info');\n    \n    chrome.alarms.clear('nextPost');\n    chrome.alarms.create('nextPost', {delayInMinutes: randomDelay / 60}); // Convert seconds to minutes\n}\n\nasync function stopAutomation() {\n    const state = await getStoredState();\n    \n    // Clear all alarms\n    chrome.alarms.clearAll();\n    \n    if (state.tabId) {\n        try {\n            await chrome.tabs.remove(state.tabId);\n        } catch (error) {\n            console.log('Tab already closed');\n        }\n    }\n    \n    // Reset automation state\n    await saveState({\n        isRunning: false,\n        comment: '',\n        urls: [],\n        currentIndex: 0,\n        tabId: null\n    });\n}\n\n// Handle alarms for reliable timing\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n    const state = await getStoredState();\n    \n    if (alarm.name === 'processPost' && state.isRunning) {\n        try {\n            await chrome.tabs.sendMessage(state.tabId, {\n                action: 'processPost',\n                comment: state.comment,\n                index: state.currentIndex\n            });\n        } catch (error) {\n            console.error('Error sending message to content script:', error);\n            await notifyError('Failed to process post: ' + error.message);\n            await stopAutomation();\n        }\n    } else if (alarm.name === 'nextPost' && state.isRunning) {\n        await processNextUrl();\n    }\n});\n\n// Handle tab closed\nchrome.tabs.onRemoved.addListener(async function(tabId) {\n    const state = await getStoredState();\n    if (tabId === state.tabId) {\n        await saveState({...state, tabId: null});\n    }\n});\n\n// Storage and notification helper functions\nasync function getStoredState() {\n    const result = await chrome.storage.local.get(['automationState']);\n    return result.automationState || {\n        isRunning: false,\n        comment: '',\n        urls: [],\n        currentIndex: 0,\n        tabId: null\n    };\n}\n\nasync function saveState(state) {\n    await chrome.storage.local.set({automationState: state});\n}\n\nasync function getAutomationStatus(sendResponse) {\n    const state = await getStoredState();\n    sendResponse(state);\n}\n\nasync function notifyPopup(message) {\n    try {\n        await chrome.runtime.sendMessage(message);\n    } catch (error) {\n        // Popup might be closed, ignore\n    }\n}\n\nasync function notifyProgress(text) {\n    // Use badge text for persistent progress indication\n    try {\n        await chrome.action.setBadgeText({text: '●'});\n        await chrome.action.setBadgeBackgroundColor({color: '#0077b5'});\n        await chrome.action.setTitle({title: `LinkedIn Auto Commenter: ${text}`});\n    } catch (error) {\n        console.log('Failed to update badge:', error);\n    }\n}\n\nasync function notifyError(message) {\n    try {\n        await chrome.action.setBadgeText({text: '!'});\n        await chrome.action.setBadgeBackgroundColor({color: '#d93025'});\n        await chrome.action.setTitle({title: `LinkedIn Auto Commenter Error: ${message}`});\n        await chrome.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon48.png',\n            title: 'LinkedIn Auto Commenter',\n            message: message\n        });\n    } catch (error) {\n        console.log('Failed to show error notification:', error);\n    }\n    \n    await notifyPopup({action: 'automationError', error: message});\n}\n\n// Helper function to generate random delay between min and max seconds\nfunction getRandomDelay(minDelay, maxDelay) {\n    return Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;\n}\n\n// Helper function to log messages to activity log and popup\nasync function logMessage(message, type = 'info') {\n    const state = await getStoredState();\n    const timestamp = new Date().toLocaleTimeString();\n    const logEntry = {\n        timestamp: timestamp,\n        message: message,\n        type: type\n    };\n    \n    // Add to activity log\n    const activityLog = state.activityLog || [];\n    activityLog.push(logEntry);\n    \n    // Keep only last 50 log entries\n    if (activityLog.length > 50) {\n        activityLog.shift();\n    }\n    \n    await saveState({...state, activityLog: activityLog});\n    \n    // Send to popup if it's open\n    await notifyPopup({\n        action: 'logMessage',\n        message: message,\n        type: type\n    });\n}","size_bytes":8235},"chrome-extension/content.js":{"content":"// Content script for LinkedIn post automation\nlet isProcessing = false;\n\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'processPost') {\n        console.log('Content script received processPost message:', message);\n        processLinkedInPost(message.comment, message.index);\n    }\n});\n\nasync function processLinkedInPost(commentText, index) {\n    if (isProcessing) {\n        console.log('Already processing, skipping...');\n        return;\n    }\n    \n    isProcessing = true;\n    console.log('Starting to process LinkedIn post...');\n    \n    try {\n        // Wait for page to load - try multiple selectors for different LinkedIn page types\n        console.log('Waiting for page to load...');\n        await waitForLinkedInPage();\n        \n        let status = '';\n        \n        // Try to like the post\n        console.log('Attempting to like post...');\n        const likeResult = await tryLikePost();\n        status += likeResult;\n        console.log('Like result:', likeResult);\n        \n        // Try to comment on the post\n        console.log('Attempting to comment on post...');\n        const commentResult = await tryCommentPost(commentText);\n        status += commentResult;\n        console.log('Comment result:', commentResult);\n        \n        // Send result back to background script\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: status || 'completed'\n        });\n        \n    } catch (error) {\n        console.error('Error processing post:', error);\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: 'error: ' + error.message\n        });\n    } finally {\n        isProcessing = false;\n    }\n}\n\nasync function waitForLinkedInPage() {\n    // Try multiple selectors for different LinkedIn page types\n    const pageSelectors = [\n        '[data-test-id=\"feed-shared-update-v2\"]', // Feed posts\n        '.feed-shared-update-v2',                 // Alternative feed posts\n        '.share-update-v2',                       // Individual posts\n        '.single-post-view',                      // Single post page\n        '[data-urn*=\"activity:\"]',                // Activity containers\n        '.activity-content',                      // Activity content\n        '.social-action-bar',                     // Action bar with like/comment buttons\n        'main[role=\"main\"]'                       // Main content area\n    ];\n    \n    console.log('Trying to find LinkedIn page elements...');\n    \n    for (const selector of pageSelectors) {\n        try {\n            console.log('Trying selector:', selector);\n            await waitForElement(selector, 2000);\n            console.log('Found element with selector:', selector);\n            return;\n        } catch (e) {\n            console.log('Selector not found:', selector);\n        }\n    }\n    \n    // If no specific selectors work, just wait a bit for page to settle\n    console.log('No specific LinkedIn elements found, waiting for page to settle...');\n    await sleep(3000);\n}\n\nasync function tryLikePost() {\n    try {\n        // Comprehensive like button selectors for current LinkedIn\n        const likeSelectors = [\n            // General like button patterns\n            'button[aria-label*=\"Like\"]',\n            'button[aria-label*=\"like\"]', \n            'button[aria-label*=\"React Like\"]',\n            '[data-control-name=\"like\"]',\n            \n            // Specific LinkedIn patterns\n            '.reactions-menu button[aria-label*=\"Like\"]',\n            '.social-actions-bar button[aria-label*=\"Like\"]',\n            '.social-action-bar button[aria-label*=\"Like\"]',\n            'button[data-test-id=\"like-button\"]',\n            'button.artdeco-button[aria-label*=\"Like\"]',\n            \n            // SVG-based like buttons\n            'button[aria-label*=\"Like\"] svg',\n            'button:has(svg[data-test-id=\"thumbs-up-outline-medium\"])',\n            'button:has(svg[data-test-id=\"thumbs-up-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Like\"]',\n            'button[title*=\"like\"]',\n            '.like-button',\n            '[data-tracking-control-name*=\"like\"]'\n        ];\n        \n        console.log('Searching for like button...');\n        let likeButton = null;\n        \n        for (const selector of likeSelectors) {\n            try {\n                console.log('Trying like selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaPressed = button.getAttribute('aria-pressed');\n                    const ariaLabel = button.getAttribute('aria-label');\n                    \n                    console.log('Button details:', {\n                        selector,\n                        ariaLabel,\n                        ariaPressed,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    // Check if this is a like button - look for both pressed and unpressed states\n                    if (ariaLabel && ariaLabel.toLowerCase().includes('like')) {\n                        // Check if already liked\n                        if (ariaPressed === 'true' || ariaLabel.toLowerCase().includes('unlike') || \n                            button.classList.contains('active') || button.classList.contains('selected')) {\n                            console.log('Post already liked - skipping');\n                            return 'already liked, ';\n                        }\n                        likeButton = button;\n                        console.log('Found like button:', button);\n                        break;\n                    }\n                }\n                if (likeButton) break;\n            } catch (e) {\n                console.log('Error with selector:', selector, e);\n            }\n        }\n        \n        if (likeButton) {\n            // Double check if already liked - this check was already done above\n            // Just proceed with clicking\n            \n            console.log('Clicking like button...');\n            likeButton.click();\n            await sleep(1500); // Wait for like to register\n            console.log('Like button clicked successfully');\n            return 'liked, ';\n        } else {\n            console.log('Like button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 10); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'like button not found, ';\n        }\n    } catch (error) {\n        console.error('Error liking post:', error);\n        return 'like failed: ' + error.message + ', ';\n    }\n}\n\nasync function tryCommentPost(commentText) {\n    try {\n        // Comprehensive comment button selectors for current LinkedIn\n        const commentSelectors = [\n            // Primary comment button patterns\n            'button[aria-label*=\"Comment\"]',\n            'button[aria-label*=\"comment\"]',\n            'button[aria-label*=\"Add a comment\"]',\n            '[data-control-name=\"comment\"]',\n            \n            // Specific LinkedIn patterns\n            '.social-actions-bar button[aria-label*=\"Comment\"]',\n            '.social-action-bar button[aria-label*=\"Comment\"]',\n            'button[data-test-id=\"comment-button\"]',\n            'button.artdeco-button[aria-label*=\"Comment\"]',\n            \n            // SVG-based comment buttons\n            'button:has(svg[data-test-id=\"comment-outline-medium\"])',\n            'button:has(svg[data-test-id=\"comment-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Comment\"]',\n            '.comment-button',\n            '[data-tracking-control-name*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment button...');\n        let commentButton = null;\n        \n        for (const selector of commentSelectors) {\n            try {\n                console.log('Trying comment selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    console.log('Comment button details:', {\n                        selector,\n                        ariaLabel,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    if (ariaLabel && ariaLabel.toLowerCase().includes('comment')) {\n                        commentButton = button;\n                        console.log('Found comment button:', button);\n                        break;\n                    }\n                }\n                if (commentButton) break;\n            } catch (e) {\n                console.log('Error with comment selector:', selector, e);\n            }\n        }\n        \n        if (!commentButton) {\n            console.log('Comment button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 15); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'comment button not found';\n        }\n        \n        console.log('Clicking comment button...');\n        commentButton.click();\n        await sleep(2000); // Wait for comment box to appear\n        \n        // Look for comment input with comprehensive selectors\n        const commentInputSelectors = [\n            // Primary comment input patterns\n            '[contenteditable=\"true\"][aria-label*=\"comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"Add a comment\"]',\n            \n            // LinkedIn specific patterns\n            '.ql-editor[contenteditable=\"true\"]',\n            '[role=\"textbox\"][contenteditable=\"true\"]',\n            '.comments-comment-texteditor [contenteditable=\"true\"]',\n            '.comment-compose-form [contenteditable=\"true\"]',\n            \n            // Fallback patterns\n            'div[contenteditable=\"true\"]',\n            '[data-placeholder*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment input...');\n        let commentInput = null;\n        \n        for (const selector of commentInputSelectors) {\n            try {\n                console.log('Trying comment input selector:', selector);\n                const inputs = document.querySelectorAll(selector);\n                console.log(`Found ${inputs.length} comment inputs for selector:`, selector);\n                \n                for (const input of inputs) {\n                    if (input.offsetHeight > 0 && input.offsetWidth > 0) { // Check if visible\n                        commentInput = input;\n                        console.log('Found visible comment input:', input);\n                        break;\n                    }\n                }\n                if (commentInput) break;\n            } catch (e) {\n                console.log('Error with comment input selector:', selector, e);\n            }\n        }\n        \n        if (!commentInput) {\n            console.log('Comment input not found. Available contenteditable elements:');\n            const editables = document.querySelectorAll('[contenteditable=\"true\"]');\n            for (let i = 0; i < Math.min(editables.length, 10); i++) {\n                const elem = editables[i];\n                console.log(`Editable ${i}:`, {\n                    ariaLabel: elem.getAttribute('aria-label'),\n                    placeholder: elem.getAttribute('placeholder'),\n                    className: elem.className,\n                    visible: elem.offsetHeight > 0 && elem.offsetWidth > 0\n                });\n            }\n            return 'comment input not found';\n        }\n        \n        // Check if we already commented - look more comprehensively\n        console.log('Checking for existing comments...');\n        const existingCommentSelectors = [\n            '[data-test-id=\"comment\"]',\n            '.comment-item', \n            '.comments-comment-item',\n            '.comment-entity',\n            '.social-comment-entity',\n            '.feed-shared-comment',\n            '.comments-comment-v2'\n        ];\n        \n        const shortCommentText = commentText.substring(0, 30).toLowerCase().trim();\n        let foundExistingComment = false;\n        \n        for (const selector of existingCommentSelectors) {\n            const comments = document.querySelectorAll(selector);\n            console.log(`Checking ${comments.length} existing comments with selector: ${selector}`);\n            \n            for (const comment of comments) {\n                const commentContent = comment.textContent.toLowerCase().trim();\n                if (commentContent.includes(shortCommentText)) {\n                    console.log('Found existing comment with matching text:', commentContent.substring(0, 100));\n                    foundExistingComment = true;\n                    break;\n                }\n            }\n            if (foundExistingComment) break;\n        }\n        \n        if (foundExistingComment) {\n            console.log('Already commented with this text - skipping');\n            return 'already commented';\n        }\n        \n        // Focus and add the comment\n        console.log('Adding comment text...');\n        commentInput.focus();\n        \n        // Clear existing content and add new comment\n        commentInput.innerHTML = '';\n        commentInput.textContent = commentText;\n        \n        // Trigger multiple events to ensure LinkedIn recognizes the input\n        const events = ['input', 'keyup', 'change'];\n        for (const eventType of events) {\n            const event = new Event(eventType, { bubbles: true });\n            commentInput.dispatchEvent(event);\n        }\n        \n        await sleep(1500);\n        \n        // Look for submit/post button\n        const submitSelectors = [\n            'button[aria-label*=\"Post comment\"]',\n            'button[aria-label*=\"Post\"]',\n            'button[data-control-name=\"comment.post\"]',\n            'button[type=\"submit\"]',\n            '.comment-compose-form button[type=\"submit\"]',\n            '.comments-comment-box button[aria-label*=\"Post\"]',\n            'button:has(span:contains(\"Post\"))',\n            'button.artdeco-button--primary'\n        ];\n        \n        console.log('Searching for submit button...');\n        let submitButton = null;\n        \n        for (const selector of submitSelectors) {\n            try {\n                console.log('Trying submit selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    const textContent = button.textContent.toLowerCase();\n                    \n                    if ((ariaLabel && ariaLabel.toLowerCase().includes('post')) || \n                        textContent.includes('post') || \n                        textContent.includes('submit')) {\n                        submitButton = button;\n                        console.log('Found submit button:', button);\n                        break;\n                    }\n                }\n                if (submitButton) break;\n            } catch (e) {\n                console.log('Error with submit selector:', selector, e);\n            }\n        }\n        \n        if (submitButton && !submitButton.disabled && !submitButton.getAttribute('disabled')) {\n            console.log('Clicking submit button...');\n            submitButton.click();\n            await sleep(3000); // Wait for comment to post\n            return 'commented';\n        } else {\n            console.log('Submit button not found or disabled. Available buttons near comment:');\n            const nearbyButtons = commentInput.closest('form, .comment-compose-form, .comments-comment-box')?.querySelectorAll('button') || [];\n            for (let i = 0; i < nearbyButtons.length; i++) {\n                const btn = nearbyButtons[i];\n                console.log(`Nearby button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    disabled: btn.disabled,\n                    className: btn.className\n                });\n            }\n            return 'submit button not found or disabled';\n        }\n    } catch (error) {\n        console.error('Error commenting on post:', error);\n        return 'comment failed: ' + error.message;\n    }\n}\n\nfunction waitForElement(selector, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const element = document.querySelector(selector);\n        if (element) {\n            resolve(element);\n            return;\n        }\n        \n        const observer = new MutationObserver((mutations) => {\n            const element = document.querySelector(selector);\n            if (element) {\n                observer.disconnect();\n                resolve(element);\n            }\n        });\n        \n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n        \n        setTimeout(() => {\n            observer.disconnect();\n            reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n        }, timeout);\n    });\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Log when content script loads\nconsole.log('LinkedIn Auto Commenter content script loaded');","size_bytes":18617},"chrome-extension/popup.js":{"content":"document.addEventListener('DOMContentLoaded', function() {\n    const commentText = document.getElementById('commentText');\n    const textInput = document.getElementById('textInput');\n    const minDelay = document.getElementById('minDelay');\n    const maxDelay = document.getElementById('maxDelay');\n    const startBtn = document.getElementById('startBtn');\n    const stopBtn = document.getElementById('stopBtn');\n    const status = document.getElementById('status');\n    const progress = document.getElementById('progress');\n    const extractedUrls = document.getElementById('extractedUrls');\n    const activityLog = document.getElementById('activityLog');\n    const logContent = document.getElementById('logContent');\n\n    let isRunning = false;\n    let currentUrls = [];\n    let currentIndex = 0;\n\n    // Load saved data\n    chrome.storage.sync.get(['commentText', 'textInput', 'minDelay', 'maxDelay'], function(data) {\n        if (data.commentText) {\n            commentText.value = data.commentText;\n        }\n        if (data.textInput) {\n            textInput.value = data.textInput;\n            extractLinkedInUrls();\n        }\n        if (data.minDelay) {\n            minDelay.value = data.minDelay;\n        }\n        if (data.maxDelay) {\n            maxDelay.value = data.maxDelay;\n        }\n    });\n\n    // Save data when changed\n    commentText.addEventListener('input', function() {\n        chrome.storage.sync.set({commentText: commentText.value});\n    });\n\n    textInput.addEventListener('input', function() {\n        chrome.storage.sync.set({textInput: textInput.value});\n        extractLinkedInUrls();\n    });\n\n    minDelay.addEventListener('input', function() {\n        chrome.storage.sync.set({minDelay: minDelay.value});\n    });\n\n    maxDelay.addEventListener('input', function() {\n        chrome.storage.sync.set({maxDelay: maxDelay.value});\n    });\n\n    // URL extraction function\n    function extractLinkedInUrls() {\n        const text = textInput.value;\n        // Updated regex to include lnkd.in and various LinkedIn URL patterns\n        const urlRegex = /https?:\\/\\/(?:(?:www\\.)?linkedin\\.com\\/(?:posts|feed\\/update|in)\\/[^\\s\\]]+|lnkd\\.in\\/[^\\s\\]]+)/gi;\n        const urls = text.match(urlRegex) || [];\n        \n        // Clean up URLs - remove any trailing characters that shouldn't be there\n        const cleanUrls = urls.map(url => {\n            // Remove trailing punctuation and whitespace\n            return url.replace(/[,.\\])\\s]*$/, '').trim();\n        });\n\n        const uniqueUrls = [...new Set(cleanUrls)];\n        currentUrls = uniqueUrls;\n        \n        if (uniqueUrls.length > 0) {\n            extractedUrls.innerHTML = `Found ${uniqueUrls.length} LinkedIn URLs:<br>${uniqueUrls.map(url => `• ${url.length > 60 ? url.substring(0, 60) + '...' : url}`).join('<br>')}`;\n        } else {\n            extractedUrls.innerHTML = 'No LinkedIn URLs found in the text.';\n        }\n    }\n\n    startBtn.addEventListener('click', function() {\n        const comment = commentText.value.trim();\n        const minDelayVal = parseInt(minDelay.value) || 2;\n        const maxDelayVal = parseInt(maxDelay.value) || 5;\n\n        if (!comment) {\n            updateStatus('Please enter a comment text', 'error');\n            return;\n        }\n\n        if (currentUrls.length === 0) {\n            updateStatus('Please add text with LinkedIn URLs', 'error');\n            return;\n        }\n\n        if (minDelayVal > maxDelayVal) {\n            updateStatus('Min delay cannot be greater than max delay', 'error');\n            return;\n        }\n\n        currentIndex = 0;\n        isRunning = true;\n\n        startBtn.style.display = 'none';\n        stopBtn.style.display = 'block';\n        activityLog.style.display = 'block';\n        \n        updateStatus('Starting automation...', 'running');\n        updateProgress(`Processing ${currentUrls.length} LinkedIn URLs`);\n        \n        addLogEntry(`Started automation with ${currentUrls.length} URLs`, 'success');\n        addLogEntry(`Using delay range: ${minDelayVal}-${maxDelayVal} seconds`, 'info');\n\n        // Send message to background script to start automation\n        chrome.runtime.sendMessage({\n            action: 'startAutomation',\n            comment: comment,\n            urls: currentUrls,\n            minDelay: minDelayVal,\n            maxDelay: maxDelayVal\n        });\n    });\n\n    stopBtn.addEventListener('click', function() {\n        isRunning = false;\n        chrome.runtime.sendMessage({action: 'stopAutomation'});\n        resetUI();\n        updateStatus('Automation stopped', 'idle');\n        updateProgress('');\n    });\n\n    // Check automation status on popup open\n    chrome.runtime.sendMessage({action: 'getStatus'}, function(state) {\n        if (state && state.isRunning) {\n            currentUrls = state.urls;\n            currentIndex = state.currentIndex;\n            isRunning = true;\n            startBtn.style.display = 'none';\n            stopBtn.style.display = 'block';\n            updateStatus(`Running: ${currentIndex + 1}/${currentUrls.length} posts`, 'running');\n            updateProgress(`Currently processing LinkedIn posts...`);\n        }\n    });\n\n    // Listen for messages from background script\n    chrome.runtime.onMessage.addListener(function(message) {\n        if (message.action === 'updateProgress') {\n            currentIndex = message.index;\n            updateProgress(`Processing ${currentIndex + 1}/${currentUrls.length}: ${message.status}`);\n            addLogEntry(`Post ${currentIndex + 1}: ${message.status}`, message.status.includes('error') ? 'error' : 'info');\n            if (message.status.includes('completed') || message.status.includes('skipped')) {\n                updateStatus(`Processed ${currentIndex + 1}/${currentUrls.length} posts`, 'running');\n            }\n        } else if (message.action === 'automationComplete') {\n            resetUI();\n            updateStatus('Automation completed successfully!', 'idle');\n            updateProgress(`Completed all ${currentUrls.length} posts`);\n            addLogEntry('Automation completed successfully!', 'success');\n        } else if (message.action === 'automationError') {\n            resetUI();\n            updateStatus(`Error: ${message.error}`, 'error');\n            updateProgress('');\n            addLogEntry(`Error: ${message.error}`, 'error');\n        } else if (message.action === 'logMessage') {\n            addLogEntry(message.message, message.type || 'info');\n        }\n    });\n\n    function addLogEntry(message, type = 'info') {\n        const timestamp = new Date().toLocaleTimeString();\n        const logEntry = document.createElement('div');\n        logEntry.className = `log-entry log-${type}`;\n        logEntry.textContent = `[${timestamp}] ${message}`;\n        logContent.appendChild(logEntry);\n        logContent.scrollTop = logContent.scrollHeight;\n    }\n\n    function updateStatus(text, type) {\n        status.textContent = text;\n        status.className = `status ${type}`;\n    }\n\n    function updateProgress(text) {\n        progress.textContent = text;\n    }\n\n    function resetUI() {\n        isRunning = false;\n        startBtn.style.display = 'block';\n        stopBtn.style.display = 'none';\n    }\n});","size_bytes":7216}},"version":1}