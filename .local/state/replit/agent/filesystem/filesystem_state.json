{"file_contents":{"content.js":{"content":"// Content script for LinkedIn post automation\nlet isProcessing = false;\n\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'processPost') {\n        console.log('Content script received processPost message:', message);\n        processLinkedInPost(message.comment, message.index);\n    }\n});\n\nasync function processLinkedInPost(commentText, index) {\n    if (isProcessing) {\n        console.log('Already processing, skipping...');\n        return;\n    }\n    \n    isProcessing = true;\n    console.log('Starting to process LinkedIn post...');\n    \n    try {\n        // Wait for page to load - try multiple selectors for different LinkedIn page types\n        console.log('Waiting for page to load...');\n        await waitForLinkedInPage();\n        \n        let status = '';\n        \n        // Try to like the post\n        console.log('Attempting to like post...');\n        const likeResult = await tryLikePost();\n        status += likeResult;\n        console.log('Like result:', likeResult);\n        \n        // Try to comment on the post\n        console.log('Attempting to comment on post...');\n        const commentResult = await tryCommentPost(commentText);\n        status += commentResult;\n        console.log('Comment result:', commentResult);\n        \n        // Send result back to background script\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: status || 'completed'\n        });\n        \n    } catch (error) {\n        console.error('Error processing post:', error);\n        chrome.runtime.sendMessage({\n            action: 'postProcessed',\n            status: 'error: ' + error.message\n        });\n    } finally {\n        isProcessing = false;\n    }\n}\n\nasync function waitForLinkedInPage() {\n    // Try multiple selectors for different LinkedIn page types\n    const pageSelectors = [\n        '[data-test-id=\"feed-shared-update-v2\"]', // Feed posts\n        '.feed-shared-update-v2',                 // Alternative feed posts\n        '.share-update-v2',                       // Individual posts\n        '.single-post-view',                      // Single post page\n        '[data-urn*=\"activity:\"]',                // Activity containers\n        '.activity-content',                      // Activity content\n        '.social-action-bar',                     // Action bar with like/comment buttons\n        'main[role=\"main\"]'                       // Main content area\n    ];\n    \n    console.log('Trying to find LinkedIn page elements...');\n    \n    for (const selector of pageSelectors) {\n        try {\n            console.log('Trying selector:', selector);\n            await waitForElement(selector, 2000);\n            console.log('Found element with selector:', selector);\n            return;\n        } catch (e) {\n            console.log('Selector not found:', selector);\n        }\n    }\n    \n    // If no specific selectors work, just wait a bit for page to settle\n    console.log('No specific LinkedIn elements found, waiting for page to settle...');\n    await sleep(3000);\n}\n\nasync function tryLikePost() {\n    try {\n        // Comprehensive like button selectors for current LinkedIn\n        const likeSelectors = [\n            // General like button patterns\n            'button[aria-label*=\"Like\"]',\n            'button[aria-label*=\"like\"]', \n            'button[aria-label*=\"React Like\"]',\n            '[data-control-name=\"like\"]',\n            \n            // Specific LinkedIn patterns\n            '.reactions-menu button[aria-label*=\"Like\"]',\n            '.social-actions-bar button[aria-label*=\"Like\"]',\n            '.social-action-bar button[aria-label*=\"Like\"]',\n            'button[data-test-id=\"like-button\"]',\n            'button.artdeco-button[aria-label*=\"Like\"]',\n            \n            // SVG-based like buttons\n            'button[aria-label*=\"Like\"] svg',\n            'button:has(svg[data-test-id=\"thumbs-up-outline-medium\"])',\n            'button:has(svg[data-test-id=\"thumbs-up-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Like\"]',\n            'button[title*=\"like\"]',\n            '.like-button',\n            '[data-tracking-control-name*=\"like\"]'\n        ];\n        \n        console.log('Searching for like button...');\n        let likeButton = null;\n        \n        for (const selector of likeSelectors) {\n            try {\n                console.log('Trying like selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaPressed = button.getAttribute('aria-pressed');\n                    const ariaLabel = button.getAttribute('aria-label');\n                    \n                    console.log('Button details:', {\n                        selector,\n                        ariaLabel,\n                        ariaPressed,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    // Check if this is a like button that hasn't been pressed\n                    if (ariaPressed === 'false' || (!ariaPressed && ariaLabel && ariaLabel.toLowerCase().includes('like'))) {\n                        likeButton = button;\n                        console.log('Found like button:', button);\n                        break;\n                    }\n                }\n                if (likeButton) break;\n            } catch (e) {\n                console.log('Error with selector:', selector, e);\n            }\n        }\n        \n        if (likeButton) {\n            // Double check if already liked\n            const ariaPressed = likeButton.getAttribute('aria-pressed');\n            const ariaLabel = likeButton.getAttribute('aria-label');\n            \n            if (ariaPressed === 'true' || (ariaLabel && ariaLabel.toLowerCase().includes('unlike'))) {\n                console.log('Post already liked');\n                return 'already liked, ';\n            }\n            \n            console.log('Clicking like button...');\n            likeButton.click();\n            await sleep(1500); // Wait for like to register\n            console.log('Like button clicked successfully');\n            return 'liked, ';\n        } else {\n            console.log('Like button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 10); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'like button not found, ';\n        }\n    } catch (error) {\n        console.error('Error liking post:', error);\n        return 'like failed: ' + error.message + ', ';\n    }\n}\n\nasync function tryCommentPost(commentText) {\n    try {\n        // Comprehensive comment button selectors for current LinkedIn\n        const commentSelectors = [\n            // Primary comment button patterns\n            'button[aria-label*=\"Comment\"]',\n            'button[aria-label*=\"comment\"]',\n            'button[aria-label*=\"Add a comment\"]',\n            '[data-control-name=\"comment\"]',\n            \n            // Specific LinkedIn patterns\n            '.social-actions-bar button[aria-label*=\"Comment\"]',\n            '.social-action-bar button[aria-label*=\"Comment\"]',\n            'button[data-test-id=\"comment-button\"]',\n            'button.artdeco-button[aria-label*=\"Comment\"]',\n            \n            // SVG-based comment buttons\n            'button:has(svg[data-test-id=\"comment-outline-medium\"])',\n            'button:has(svg[data-test-id=\"comment-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Comment\"]',\n            '.comment-button',\n            '[data-tracking-control-name*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment button...');\n        let commentButton = null;\n        \n        for (const selector of commentSelectors) {\n            try {\n                console.log('Trying comment selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    console.log('Comment button details:', {\n                        selector,\n                        ariaLabel,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    if (ariaLabel && ariaLabel.toLowerCase().includes('comment')) {\n                        commentButton = button;\n                        console.log('Found comment button:', button);\n                        break;\n                    }\n                }\n                if (commentButton) break;\n            } catch (e) {\n                console.log('Error with comment selector:', selector, e);\n            }\n        }\n        \n        if (!commentButton) {\n            console.log('Comment button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 15); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'comment button not found';\n        }\n        \n        console.log('Clicking comment button...');\n        commentButton.click();\n        await sleep(2000); // Wait for comment box to appear\n        \n        // Look for comment input with comprehensive selectors\n        const commentInputSelectors = [\n            // Primary comment input patterns\n            '[contenteditable=\"true\"][aria-label*=\"comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"Add a comment\"]',\n            \n            // LinkedIn specific patterns\n            '.ql-editor[contenteditable=\"true\"]',\n            '[role=\"textbox\"][contenteditable=\"true\"]',\n            '.comments-comment-texteditor [contenteditable=\"true\"]',\n            '.comment-compose-form [contenteditable=\"true\"]',\n            \n            // Fallback patterns\n            'div[contenteditable=\"true\"]',\n            '[data-placeholder*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment input...');\n        let commentInput = null;\n        \n        for (const selector of commentInputSelectors) {\n            try {\n                console.log('Trying comment input selector:', selector);\n                const inputs = document.querySelectorAll(selector);\n                console.log(`Found ${inputs.length} comment inputs for selector:`, selector);\n                \n                for (const input of inputs) {\n                    if (input.offsetHeight > 0 && input.offsetWidth > 0) { // Check if visible\n                        commentInput = input;\n                        console.log('Found visible comment input:', input);\n                        break;\n                    }\n                }\n                if (commentInput) break;\n            } catch (e) {\n                console.log('Error with comment input selector:', selector, e);\n            }\n        }\n        \n        if (!commentInput) {\n            console.log('Comment input not found. Available contenteditable elements:');\n            const editables = document.querySelectorAll('[contenteditable=\"true\"]');\n            for (let i = 0; i < Math.min(editables.length, 10); i++) {\n                const elem = editables[i];\n                console.log(`Editable ${i}:`, {\n                    ariaLabel: elem.getAttribute('aria-label'),\n                    placeholder: elem.getAttribute('placeholder'),\n                    className: elem.className,\n                    visible: elem.offsetHeight > 0 && elem.offsetWidth > 0\n                });\n            }\n            return 'comment input not found';\n        }\n        \n        // Check if we already commented\n        console.log('Checking for existing comments...');\n        const existingComments = document.querySelectorAll('[data-test-id=\"comment\"], .comment-item, .comments-comment-item');\n        const shortCommentText = commentText.substring(0, 50);\n        for (const comment of existingComments) {\n            if (comment.textContent.includes(shortCommentText)) {\n                console.log('Already commented with this text');\n                return 'already commented';\n            }\n        }\n        \n        // Focus and add the comment\n        console.log('Adding comment text...');\n        commentInput.focus();\n        \n        // Clear existing content and add new comment\n        commentInput.innerHTML = '';\n        commentInput.textContent = commentText;\n        \n        // Trigger multiple events to ensure LinkedIn recognizes the input\n        const events = ['input', 'keyup', 'change'];\n        for (const eventType of events) {\n            const event = new Event(eventType, { bubbles: true });\n            commentInput.dispatchEvent(event);\n        }\n        \n        await sleep(1500);\n        \n        // Look for submit/post button\n        const submitSelectors = [\n            'button[aria-label*=\"Post comment\"]',\n            'button[aria-label*=\"Post\"]',\n            'button[data-control-name=\"comment.post\"]',\n            'button[type=\"submit\"]',\n            '.comment-compose-form button[type=\"submit\"]',\n            '.comments-comment-box button[aria-label*=\"Post\"]',\n            'button:has(span:contains(\"Post\"))',\n            'button.artdeco-button--primary'\n        ];\n        \n        console.log('Searching for submit button...');\n        let submitButton = null;\n        \n        for (const selector of submitSelectors) {\n            try {\n                console.log('Trying submit selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    const textContent = button.textContent.toLowerCase();\n                    \n                    if ((ariaLabel && ariaLabel.toLowerCase().includes('post')) || \n                        textContent.includes('post') || \n                        textContent.includes('submit')) {\n                        submitButton = button;\n                        console.log('Found submit button:', button);\n                        break;\n                    }\n                }\n                if (submitButton) break;\n            } catch (e) {\n                console.log('Error with submit selector:', selector, e);\n            }\n        }\n        \n        if (submitButton && !submitButton.disabled && !submitButton.getAttribute('disabled')) {\n            console.log('Clicking submit button...');\n            submitButton.click();\n            await sleep(3000); // Wait for comment to post\n            return 'commented';\n        } else {\n            console.log('Submit button not found or disabled. Available buttons near comment:');\n            const nearbyButtons = commentInput.closest('form, .comment-compose-form, .comments-comment-box')?.querySelectorAll('button') || [];\n            for (let i = 0; i < nearbyButtons.length; i++) {\n                const btn = nearbyButtons[i];\n                console.log(`Nearby button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    disabled: btn.disabled,\n                    className: btn.className\n                });\n            }\n            return 'submit button not found or disabled';\n        }\n    } catch (error) {\n        console.error('Error commenting on post:', error);\n        return 'comment failed: ' + error.message;\n    }\n}\n\nfunction waitForElement(selector, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const element = document.querySelector(selector);\n        if (element) {\n            resolve(element);\n            return;\n        }\n        \n        const observer = new MutationObserver((mutations) => {\n            const element = document.querySelector(selector);\n            if (element) {\n                observer.disconnect();\n                resolve(element);\n            }\n        });\n        \n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n        \n        setTimeout(() => {\n            observer.disconnect();\n            reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n        }, timeout);\n    });\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Log when content script loads\nconsole.log('LinkedIn Auto Commenter content script loaded');","size_bytes":17607},"replit.md":{"content":"# LinkedIn Auto Commenter Chrome Extension\n\n## Overview\n\nThis project is a Chrome browser extension that automates interactions with LinkedIn posts. The extension allows users to automatically like and comment on multiple LinkedIn posts by providing a list of post URLs and a comment template. It features a user-friendly popup interface for configuration, background processing for automation management, and content script injection for DOM manipulation on LinkedIn pages. The project includes a simple Python HTTP server for distributing the extension files during development and testing.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\nThe extension uses Chrome's Manifest V3 architecture with a popup-based user interface. The popup (popup.html/popup.js) provides a clean form interface where users can input their comment text and LinkedIn post URLs. The interface includes real-time status updates, progress tracking, and persistent storage of user inputs using Chrome's sync storage API.\n\n### Extension Architecture\nThe system follows Chrome extension best practices with clear separation of concerns:\n\n- **Background Service Worker** (background.js): Manages the automation workflow, maintains state across browser sessions, and coordinates between different extension components. Uses Chrome's storage API for persistence and handles tab management for sequential post processing.\n\n- **Content Scripts** (content.js): Injected into LinkedIn pages to perform DOM manipulation. Handles the actual liking and commenting actions by finding and interacting with LinkedIn's UI elements. Implements robust element waiting and error handling for reliable automation.\n\n- **Popup Interface** (popup.js): Provides user controls and real-time feedback. Manages user input validation, displays automation progress, and communicates with the background worker.\n\n### Automation Flow\nThe extension implements a sequential processing pattern where posts are opened one at a time in controlled tabs. This approach ensures reliable execution and reduces the risk of being flagged by LinkedIn's anti-automation systems. The workflow includes validation of already-liked/commented posts to avoid duplicate actions.\n\n### State Management\nUses Chrome's storage API for state persistence, ensuring the automation can resume after browser restarts or extension updates. The state includes current automation status, progress tracking, and user preferences.\n\n## External Dependencies\n\n### Chrome APIs\n- **chrome.storage**: For persistent data storage and user preferences\n- **chrome.tabs**: For tab management and URL navigation during automation\n- **chrome.runtime**: For inter-component messaging and extension lifecycle management\n- **chrome.alarms**: For timing and scheduling automation tasks\n- **chrome.notifications**: For user notifications and status updates\n\n### Target Platform\n- **LinkedIn.com**: The extension specifically targets LinkedIn's web interface and relies on LinkedIn's DOM structure for post interaction. The content scripts are designed to work with LinkedIn's current UI patterns for like buttons, comment sections, and post identification.\n\n### Development Server\n- **Python HTTP Server**: A simple development server (server.py) that serves extension files with proper CORS headers for testing and distribution during development phases.\n\n### Browser Compatibility\nDesigned for Chrome browsers supporting Manifest V3, with permissions configured for LinkedIn domain access and necessary browser APIs for automation functionality.","size_bytes":3626},"server.py":{"content":"#!/usr/bin/env python3\nimport http.server\nimport socketserver\nimport os\n\nPORT = 5000\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache')\n        super().end_headers()\n\nif __name__ == \"__main__\":\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    with socketserver.TCPServer((\"0.0.0.0\", PORT), MyHTTPRequestHandler) as httpd:\n        print(f\"Serving Chrome extension files at http://0.0.0.0:{PORT}\")\n        print(f\"Extension files available for download and installation\")\n        httpd.serve_forever()","size_bytes":826},"chrome-extension/background.js":{"content":"// Enhanced error codes for comprehensive diagnostics\nconst ERROR_CODES = {\n    AUTH_401: 'AUTH_401',\n    AUTH_EXPIRED: 'AUTH_EXPIRED', \n    RATE_LIMIT: 'RATE_LIMIT',\n    NETWORK_TIMEOUT: 'NETWORK_TIMEOUT',\n    DOM_NOT_FOUND: 'DOM_NOT_FOUND',\n    ACTION_VERIFICATION_FAILED: 'ACTION_VERIFICATION_FAILED',\n    TAB_CLOSED: 'TAB_CLOSED',\n    CONTENT_SCRIPT_ERROR: 'CONTENT_SCRIPT_ERROR',\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n};\n\n// Use chrome.storage to persist state across service worker suspensions\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'startAutomation') {\n        startAutomation(message.comment, message.urls, message.minDelay, message.maxDelay, message.urlTimeout, message.retryLimit, message.dryRun, message.enableLike, message.enableComment);\n    } else if (message.action === 'stopAutomation') {\n        stopAutomation();\n    } else if (message.action === 'pauseAutomation') {\n        pauseAutomation();\n    } else if (message.action === 'resumeAutomation') {\n        resumeAutomation();\n    } else if (message.action === 'postProcessed') {\n        handlePostProcessed(message);\n    } else if (message.action === 'getStatus') {\n        getAutomationStatus(sendResponse);\n        return true; // Keep message channel open for async response\n    } else if (message.action === 'exportLogs') {\n        exportLogs(message.format, sendResponse);\n        return true;\n    }\n});\n\nasync function startAutomation(comment, urls, minDelay = 2, maxDelay = 5, urlTimeout = 30, retryLimit = 2, dryRun = false, enableLike = true, enableComment = true) {\n    const state = await getStoredState();\n    if (state.isRunning) {\n        return;\n    }\n\n    const newState = {\n        isRunning: true,\n        comment: comment,\n        urls: urls,\n        currentIndex: 0,\n        tabId: null,\n        startTime: Date.now(),\n        minDelay: minDelay,\n        maxDelay: maxDelay,\n        urlTimeout: urlTimeout,\n        maxRetries: retryLimit,\n        dryRun: dryRun,\n        enableLike: enableLike,\n        enableComment: enableComment,\n        isPaused: false,\n        activityLog: [],\n        urlStatuses: new Array(urls.length).fill().map(() => ({ \n            status: 'pending', \n            attempts: 0, \n            liked: false, \n            commented: false, \n            skipped: false,\n            error: null,\n            startTime: null,\n            endTime: null\n        })),\n        statistics: {\n            total: urls.length,\n            processed: 0,\n            liked: 0,\n            commented: 0,\n            skipped: 0,\n            failed: 0\n        },\n        currentTimeout: null\n    };\n\n    await saveState(newState);\n    await logStructuredMessage(`Starting automation with ${urls.length} URLs${dryRun ? ' (DRY-RUN)' : ''}`, 'success', {\n        totalUrls: urls.length,\n        delay: `${minDelay}-${maxDelay}s`,\n        timeout: `${urlTimeout}s`,\n        maxRetries: retryLimit,\n        dryRun: dryRun\n    });\n    \n    try {\n        await processNextUrl();\n    } catch (error) {\n        console.error('Automation error:', error);\n        const errorCode = ERROR_CODES.UNKNOWN_ERROR;\n        await notifyError(`${errorCode}: ${error.message}`);\n        await logStructuredMessage('Automation startup failed', 'error', {\n            errorCode: errorCode,\n            message: error.message\n        });\n        await stopAutomation();\n    }\n}\n\nasync function processNextUrl() {\n    const state = await getStoredState();\n    \n    if (!state.isRunning) {\n        return;\n    }\n    \n    // Handle pause state - don't process but don't stop either\n    if (state.isPaused) {\n        console.log('Automation is paused, waiting for resume...');\n        return;\n    }\n    \n    // Check if all URLs are processed\n    if (state.currentIndex >= state.urls.length) {\n        // All URLs processed - generate summary\n        const summary = generateSummary(state);\n        await logStructuredMessage('Automation completed', 'success', summary);\n        await notifyProgress(`Completed: ${summary.processed}/${summary.total} URLs`);\n        await notifyPopup({action: 'automationComplete', summary: summary});\n        await stopAutomation();\n        return;\n    }\n\n    const currentUrl = state.urls[state.currentIndex];\n    const urlStatus = state.urlStatuses[state.currentIndex];\n    \n    // Start tracking this URL\n    urlStatus.startTime = Date.now();\n    urlStatus.status = 'processing';\n    await saveState(state);\n    \n    await logStructuredMessage(`Opened: ${currentUrl}`, 'info', {\n        url: currentUrl,\n        index: state.currentIndex + 1,\n        total: state.urls.length,\n        attempt: urlStatus.attempts + 1\n    });\n    \n    await notifyProgress(`Processing ${state.currentIndex + 1}/${state.urls.length}: opening post...`);\n    await notifyPopup({\n        action: 'updateProgress',\n        index: state.currentIndex,\n        status: `opening post... (attempt ${urlStatus.attempts + 1})`\n    });\n\n    // Create or update tab with the LinkedIn post\n    try {\n        let tabId = state.tabId;\n        \n        if (tabId) {\n            try {\n                await chrome.tabs.update(tabId, {url: currentUrl, active: true});\n            } catch (error) {\n                // Tab might have been closed, create a new one\n                const tab = await chrome.tabs.create({url: currentUrl, active: true});\n                tabId = tab.id;\n                await saveState({...state, tabId: tabId});\n            }\n        } else {\n            const tab = await chrome.tabs.create({url: currentUrl, active: true});\n            tabId = tab.id;\n            await saveState({...state, tabId: tabId});\n        }\n\n        // Set up watchdog timer only for timeouts >= 1 minute\n        const urlTimeoutSeconds = state.urlTimeout || 30;\n        if (urlTimeoutSeconds >= 60) {\n            const timeoutMinutes = Math.ceil(urlTimeoutSeconds / 60);\n            chrome.alarms.clear('urlTimeout');\n            chrome.alarms.create('urlTimeout', {delayInMinutes: timeoutMinutes});\n        }\n        \n        // Processing will be triggered by tab loading event instead of alarm\n        \n    } catch (error) {\n        console.error('Error creating tab:', error);\n        const errorCode = ERROR_CODES.TAB_CLOSED;\n        await handleUrlError(currentUrl, errorCode, error.message, state);\n    }\n}\n\nasync function handlePostProcessed(message) {\n    const state = await getStoredState();\n    if (!state.isRunning) return;\n    \n    // Clear the timeout since processing completed\n    chrome.alarms.clear('urlTimeout');\n    \n    const urlStatus = state.urlStatuses[state.currentIndex];\n    const currentUrl = state.urls[state.currentIndex];\n    \n    urlStatus.endTime = Date.now();\n    const processingTime = (urlStatus.endTime - urlStatus.startTime) / 1000;\n    \n    if (message.error) {\n        // Handle error case\n        await handleUrlError(currentUrl, message.errorCode || ERROR_CODES.CONTENT_SCRIPT_ERROR, message.error, state);\n        return;\n    }\n    \n    // Process successful result\n    urlStatus.status = 'completed';\n    urlStatus.liked = message.liked || false;\n    urlStatus.commented = message.commented || false;\n    urlStatus.skipped = message.skipped || false;\n    \n    // Update statistics\n    state.statistics.processed++;\n    if (message.liked) state.statistics.liked++;\n    if (message.commented) state.statistics.commented++;\n    if (message.skipped) state.statistics.skipped++;\n    \n    // Log detailed result\n    const logData = {\n        url: currentUrl,\n        processingTime: `${processingTime.toFixed(1)}s`,\n        liked: message.liked,\n        commented: message.commented,\n        skipped: message.skipped,\n        reason: message.reason || null\n    };\n    \n    if (message.skipped) {\n        await logStructuredMessage(`Skipped: ${currentUrl}`, 'warning', logData);\n    } else {\n        const actions = [];\n        if (message.liked) actions.push('Liked');\n        if (message.commented) actions.push('Commented');\n        const actionStr = actions.join(' + ') || 'No actions';\n        await logStructuredMessage(`Done: ${currentUrl} | ${actionStr}`, 'success', logData);\n    }\n    \n    await notifyProgress(`Post ${state.currentIndex + 1}: ${message.status}`);\n    await notifyPopup({\n        action: 'updateProgress',\n        index: state.currentIndex,\n        status: message.status,\n        statistics: state.statistics\n    });\n\n    // Move to next URL\n    const newIndex = state.currentIndex + 1;\n    await saveState({...state, currentIndex: newIndex});\n    \n    // Use random delay before next post\n    const randomDelay = getRandomDelay(state.minDelay || 2, state.maxDelay || 5);\n    await logStructuredMessage(`Waiting ${randomDelay}s before next post...`, 'info', {delay: randomDelay});\n    \n    if (randomDelay >= 60) {\n        // Use alarm for delays >= 1 minute\n        chrome.alarms.clear('nextPost');\n        chrome.alarms.create('nextPost', {delayInMinutes: randomDelay / 60});\n    } else {\n        // Use setTimeout for sub-minute delays\n        setTimeout(async () => {\n            const currentState = await getStoredState();\n            if (currentState.isRunning && !currentState.isPaused) {\n                await processNextUrl();\n            }\n        }, randomDelay * 1000);\n    }\n}\n\nasync function pauseAutomation() {\n    const state = await getStoredState();\n    if (!state.isRunning) return;\n    \n    // Clear all pending alarms\n    chrome.alarms.clearAll();\n    \n    // Set paused state\n    await saveState({...state, isPaused: true});\n    \n    await logStructuredMessage('Automation paused by user', 'warning');\n    await notifyPopup({action: 'automationPaused'});\n    \n    try {\n        await chrome.action.setBadgeText({text: '⏸'});\n        await chrome.action.setBadgeBackgroundColor({color: '#f59e0b'});\n        await chrome.action.setTitle({title: 'LinkedIn Auto Commenter: Paused'});\n    } catch (error) {\n        console.log('Failed to update badge:', error);\n    }\n}\n\nasync function resumeAutomation() {\n    const state = await getStoredState();\n    if (!state.isRunning || !state.isPaused) return;\n    \n    // Resume state\n    await saveState({...state, isPaused: false});\n    \n    await logStructuredMessage('Automation resumed by user', 'info');\n    await notifyPopup({action: 'automationResumed'});\n    \n    // Continue processing from current position\n    await processNextUrl();\n}\n\nasync function stopAutomation() {\n    const state = await getStoredState();\n    \n    // Clear all alarms\n    chrome.alarms.clearAll();\n    \n    if (state.tabId) {\n        try {\n            await chrome.tabs.remove(state.tabId);\n        } catch (error) {\n            console.log('Tab already closed');\n        }\n    }\n    \n    // Generate final summary if automation was running\n    if (state.isRunning && state.statistics) {\n        const summary = generateSummary(state);\n        await logStructuredMessage('Automation stopped', 'warning', summary);\n    }\n    \n    // Reset automation state but preserve logs\n    const preservedLogs = state.activityLog || [];\n    await saveState({\n        isRunning: false,\n        comment: '',\n        urls: [],\n        currentIndex: 0,\n        tabId: null,\n        activityLog: preservedLogs\n    });\n    \n    // Reset badge\n    try {\n        await chrome.action.setBadgeText({text: ''});\n        await chrome.action.setTitle({title: 'LinkedIn Auto Commenter'});\n    } catch (error) {\n        console.log('Failed to reset badge:', error);\n    }\n}\n\n// Handle alarms for reliable timing and timeouts\nchrome.alarms.onAlarm.addListener(async (alarm) => {\n    const state = await getStoredState();\n    \n    if (alarm.name === 'processPost' && state.isRunning && !state.isPaused) {\n        try {\n            await chrome.tabs.sendMessage(state.tabId, {\n                action: 'processPost',\n                comment: state.comment,\n                index: state.currentIndex,\n                urlTimeout: state.urlTimeout || 30,\n                dryRun: state.dryRun || false,\n                enableLike: state.enableLike !== false,\n                enableComment: state.enableComment !== false\n            });\n        } catch (error) {\n            console.error('Error sending message to content script:', error);\n            const errorCode = ERROR_CODES.CONTENT_SCRIPT_ERROR;\n            await handleUrlError(state.urls[state.currentIndex], errorCode, error.message, state);\n        }\n    } else if (alarm.name === 'nextPost' && state.isRunning && !state.isPaused) {\n        await processNextUrl();\n    } else if (alarm.name === 'urlTimeout' && state.isRunning && !state.isPaused) {\n        // Handle timeout (only for timeouts >= 1 minute)\n        const currentUrl = state.urls[state.currentIndex];\n        const errorCode = ERROR_CODES.NETWORK_TIMEOUT;\n        await handleUrlError(currentUrl, errorCode, `URL processing timeout after ${state.urlTimeout || 30}s`, state);\n    } else if (alarm.name === 'retryUrl' && state.isRunning && !state.isPaused) {\n        // Handle retry after backoff delay (for retries >= 1 minute)\n        await processNextUrl();\n    }\n});\n\n// Handle tab loading completion to trigger processing\nchrome.tabs.onUpdated.addListener(async function(tabId, changeInfo, tab) {\n    if (changeInfo.status === 'complete') {\n        const state = await getStoredState();\n        \n        // Check if this is our automation tab and we're ready to process\n        if (state.isRunning && !state.isPaused && tabId === state.tabId && \n            state.urls && state.currentIndex < state.urls.length) {\n            \n            const currentUrl = state.urls[state.currentIndex];\n            \n            // Verify this tab is for the current URL we're processing\n            if (tab.url && (tab.url === currentUrl || tab.url.includes('linkedin.com'))) {\n                console.log('Tab loaded, starting post processing...');\n                \n                // Give a brief moment for the page to settle, then start processing\n                setTimeout(async () => {\n                    const currentState = await getStoredState();\n                    if (currentState.isRunning && !currentState.isPaused && tabId === currentState.tabId) {\n                        try {\n                            await chrome.tabs.sendMessage(tabId, {\n                                action: 'processPost',\n                                comment: currentState.comment,\n                                index: currentState.currentIndex,\n                                urlTimeout: currentState.urlTimeout || 30,\n                                dryRun: currentState.dryRun || false,\n                                enableLike: currentState.enableLike !== false,\n                                enableComment: currentState.enableComment !== false\n                            });\n                        } catch (error) {\n                            console.error('Error sending message to content script:', error);\n                            const errorCode = ERROR_CODES.CONTENT_SCRIPT_ERROR;\n                            await handleUrlError(currentState.urls[currentState.currentIndex], errorCode, error.message, currentState);\n                        }\n                    }\n                }, 2000); // 2 second settle time\n            }\n        }\n    }\n});\n\n// Handle tab closed\nchrome.tabs.onRemoved.addListener(async function(tabId) {\n    const state = await getStoredState();\n    if (tabId === state.tabId) {\n        await saveState({...state, tabId: null});\n    }\n});\n\n// Storage and notification helper functions\nasync function getStoredState() {\n    const result = await chrome.storage.local.get(['automationState']);\n    return result.automationState || {\n        isRunning: false,\n        comment: '',\n        urls: [],\n        currentIndex: 0,\n        tabId: null\n    };\n}\n\nasync function saveState(state) {\n    await chrome.storage.local.set({automationState: state});\n}\n\nasync function getAutomationStatus(sendResponse) {\n    const state = await getStoredState();\n    sendResponse(state);\n}\n\nasync function notifyPopup(message) {\n    try {\n        await chrome.runtime.sendMessage(message);\n    } catch (error) {\n        // Popup might be closed, ignore\n    }\n}\n\nasync function notifyProgress(text) {\n    // Use badge text for persistent progress indication\n    try {\n        await chrome.action.setBadgeText({text: '●'});\n        await chrome.action.setBadgeBackgroundColor({color: '#0077b5'});\n        await chrome.action.setTitle({title: `LinkedIn Auto Commenter: ${text}`});\n    } catch (error) {\n        console.log('Failed to update badge:', error);\n    }\n}\n\nasync function notifyError(message) {\n    try {\n        await chrome.action.setBadgeText({text: '!'});\n        await chrome.action.setBadgeBackgroundColor({color: '#d93025'});\n        await chrome.action.setTitle({title: `LinkedIn Auto Commenter Error: ${message}`});\n        await chrome.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon48.png',\n            title: 'LinkedIn Auto Commenter',\n            message: message\n        });\n    } catch (error) {\n        console.log('Failed to show error notification:', error);\n    }\n    \n    await notifyPopup({action: 'automationError', error: message});\n}\n\n// Enhanced error handling with retry logic\nasync function handleUrlError(url, errorCode, errorMessage, state) {\n    const urlStatus = state.urlStatuses[state.currentIndex];\n    urlStatus.attempts++;\n    urlStatus.error = {code: errorCode, message: errorMessage};\n    urlStatus.endTime = Date.now();\n    \n    // Clear any pending timeouts\n    chrome.alarms.clear('urlTimeout');\n    \n    // Check if we should retry\n    const maxRetries = state.maxRetries || 2;\n    if (urlStatus.attempts <= maxRetries) {\n        // Retry with exponential backoff\n        const backoffDelay = Math.min(5 * Math.pow(2, urlStatus.attempts - 1), 30); // Cap at 30s\n        \n        await logStructuredMessage(`Error: ${url} | ${errorCode} | ${errorMessage} (attempt ${urlStatus.attempts}/${maxRetries + 1})`, 'error', {\n            url: url,\n            errorCode: errorCode,\n            message: errorMessage,\n            attempt: urlStatus.attempts,\n            maxRetries: maxRetries + 1,\n            nextRetry: `${backoffDelay}s`\n        });\n        \n        // Reset status for retry\n        urlStatus.status = 'retrying';\n        await saveState(state);\n        \n        // Schedule retry\n        if (backoffDelay >= 60) {\n            // Use alarm for delays >= 1 minute\n            chrome.alarms.clear('retryUrl');\n            chrome.alarms.create('retryUrl', {delayInMinutes: backoffDelay / 60});\n        } else {\n            // Use setTimeout for sub-minute delays\n            setTimeout(async () => {\n                const currentState = await getStoredState();\n                if (currentState.isRunning && !currentState.isPaused) {\n                    await processNextUrl();\n                }\n            }, backoffDelay * 1000);\n        }\n        return;\n    }\n    \n    // Max retries reached - mark as failed and continue\n    urlStatus.status = 'failed';\n    state.statistics.failed++;\n    \n    await logStructuredMessage(`Failed: ${url} | ${errorCode} | ${errorMessage} (final attempt)`, 'error', {\n        url: url,\n        errorCode: errorCode,\n        message: errorMessage,\n        totalAttempts: urlStatus.attempts\n    });\n    \n    await notifyPopup({\n        action: 'updateProgress',\n        index: state.currentIndex,\n        status: `failed: ${errorCode}`,\n        statistics: state.statistics\n    });\n    \n    // Move to next URL\n    const newIndex = state.currentIndex + 1;\n    await saveState({...state, currentIndex: newIndex});\n    \n    // Continue with next URL after brief delay (3 seconds)\n    setTimeout(async () => {\n        const currentState = await getStoredState();\n        if (currentState.isRunning && !currentState.isPaused) {\n            await processNextUrl();\n        }\n    }, 3000);\n}\n\n// Generate completion summary\nfunction generateSummary(state) {\n    const stats = state.statistics;\n    const completionTime = Date.now() - state.startTime;\n    \n    return {\n        total: stats.total,\n        processed: stats.processed,\n        liked: stats.liked,\n        commented: stats.commented,\n        skipped: stats.skipped,\n        failed: stats.failed,\n        completionTime: Math.round(completionTime / 1000),\n        successRate: stats.total > 0 ? Math.round((stats.processed / stats.total) * 100) : 0\n    };\n}\n\n// Enhanced structured logging\nasync function logStructuredMessage(message, type = 'info', data = {}) {\n    const state = await getStoredState();\n    const timestamp = new Date().toISOString();\n    const logEntry = {\n        timestamp: timestamp,\n        message: message,\n        type: type,\n        data: data,\n        displayTime: new Date().toLocaleTimeString()\n    };\n    \n    // Add to activity log\n    const activityLog = state.activityLog || [];\n    activityLog.push(logEntry);\n    \n    // Keep only last 100 log entries for better visibility\n    if (activityLog.length > 100) {\n        activityLog.shift();\n    }\n    \n    await saveState({...state, activityLog: activityLog});\n    \n    // Send to popup if it's open\n    await notifyPopup({\n        action: 'logMessage',\n        message: message,\n        type: type,\n        data: data,\n        timestamp: logEntry.displayTime\n    });\n}\n\n// Export logs functionality\nasync function exportLogs(format, sendResponse) {\n    const state = await getStoredState();\n    const logs = state.activityLog || [];\n    \n    try {\n        let exportData;\n        \n        if (format === 'csv') {\n            const headers = ['Timestamp', 'Type', 'Message', 'Data'];\n            const csvRows = [headers.join(',')];\n            \n            logs.forEach(log => {\n                const row = [\n                    log.timestamp,\n                    log.type,\n                    `\"${log.message.replace(/\"/g, '\"\"')}\"`, // Escape quotes\n                    `\"${JSON.stringify(log.data || {}).replace(/\"/g, '\"\"')}\"`\n                ];\n                csvRows.push(row.join(','));\n            });\n            \n            exportData = csvRows.join('\\n');\n        } else {\n            // JSON format\n            exportData = JSON.stringify({\n                exportTime: new Date().toISOString(),\n                statistics: state.statistics || {},\n                logs: logs\n            }, null, 2);\n        }\n        \n        sendResponse({success: true, data: exportData, format: format});\n    } catch (error) {\n        sendResponse({success: false, error: error.message});\n    }\n}\n\n// Helper function to generate random delay between min and max seconds\nfunction getRandomDelay(minDelay, maxDelay) {\n    return Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;\n}\n\n// Helper function to log messages to activity log and popup\nasync function logMessage(message, type = 'info') {\n    const state = await getStoredState();\n    const timestamp = new Date().toLocaleTimeString();\n    const logEntry = {\n        timestamp: timestamp,\n        message: message,\n        type: type\n    };\n    \n    // Add to activity log\n    const activityLog = state.activityLog || [];\n    activityLog.push(logEntry);\n    \n    // Keep only last 50 log entries\n    if (activityLog.length > 50) {\n        activityLog.shift();\n    }\n    \n    await saveState({...state, activityLog: activityLog});\n    \n    // Send to popup if it's open\n    await notifyPopup({\n        action: 'logMessage',\n        message: message,\n        type: type\n    });\n}","size_bytes":23570},"chrome-extension/content.js":{"content":"// Enhanced content script for LinkedIn post automation with strict idempotency\nlet isProcessing = false;\nlet processingTimeout = null;\n\n// Enhanced error codes matching background script\nconst ERROR_CODES = {\n    AUTH_401: 'AUTH_401',\n    AUTH_EXPIRED: 'AUTH_EXPIRED', \n    RATE_LIMIT: 'RATE_LIMIT',\n    NETWORK_TIMEOUT: 'NETWORK_TIMEOUT',\n    DOM_NOT_FOUND: 'DOM_NOT_FOUND',\n    ACTION_VERIFICATION_FAILED: 'ACTION_VERIFICATION_FAILED',\n    ALREADY_PROCESSED: 'ALREADY_PROCESSED'\n};\n\nchrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {\n    if (message.action === 'processPost') {\n        console.log('Content script received processPost message:', message);\n        processLinkedInPost(\n            message.comment, \n            message.index, \n            message.urlTimeout || 30, \n            message.dryRun || false,\n            message.enableLike !== false,\n            message.enableComment !== false\n        );\n    }\n});\n\nasync function processLinkedInPost(commentText, index, timeout = 30, dryRun = false, enableLike = true, enableComment = true) {\n    if (isProcessing) {\n        console.log('Already processing, skipping...');\n        return;\n    }\n    \n    isProcessing = true;\n    console.log(`Starting to process LinkedIn post with ${timeout}s timeout...`);\n    console.log(`Action preferences: Like=${enableLike}, Comment=${enableComment}`);\n    \n    // Set up timeout for this processing\n    processingTimeout = setTimeout(() => {\n        console.error('Processing timeout reached');\n        sendResult({\n            error: `Processing timeout after ${timeout}s`,\n            errorCode: ERROR_CODES.NETWORK_TIMEOUT,\n            skipped: true\n        });\n        isProcessing = false;\n    }, timeout * 1000);\n    \n    try {\n        // Wait for page to load\n        console.log('Waiting for page to load...');\n        await waitForLinkedInPage();\n        \n        // Check current like and comment status with strict idempotency\n        console.log('Checking current post status for idempotency...');\n        const currentStatus = await checkCurrentPostStatus(commentText);\n        console.log('Current post status:', currentStatus);\n        \n        // Implement strict idempotency matrix\n        const result = await processAccordingToMatrix(currentStatus, commentText, dryRun, enableLike, enableComment);\n        \n        sendResult(result);\n        \n    } catch (error) {\n        console.error('Error processing post:', error);\n        sendResult({\n            error: error.message,\n            errorCode: ERROR_CODES.DOM_NOT_FOUND,\n            skipped: true\n        });\n    } finally {\n        if (processingTimeout) {\n            clearTimeout(processingTimeout);\n            processingTimeout = null;\n        }\n        isProcessing = false;\n    }\n}\n\n// Helper function to send results back to background script\nfunction sendResult(result) {\n    chrome.runtime.sendMessage({\n        action: 'postProcessed',\n        status: result.status || 'processed',\n        liked: result.liked || false,\n        commented: result.commented || false,\n        skipped: result.skipped || false,\n        reason: result.reason || null,\n        error: result.error || null,\n        errorCode: result.errorCode || null\n    });\n}\n\n// Check current like and comment status for strict idempotency\nasync function checkCurrentPostStatus(commentText) {\n    const status = {\n        isLiked: false,\n        hasCommented: false,\n        postContainer: null\n    };\n    \n    // Find the post container first\n    const postSelectors = [\n        '[data-test-id=\"feed-shared-update-v2\"]',\n        '.feed-shared-update-v2', \n        '.share-update-v2',\n        '.single-post-view',\n        '[data-urn*=\"activity:\"]',\n        'article[data-urn]'\n    ];\n    \n    for (const selector of postSelectors) {\n        const container = document.querySelector(selector);\n        if (container) {\n            status.postContainer = container;\n            console.log('Found post container:', selector);\n            break;\n        }\n    }\n    \n    if (!status.postContainer) {\n        status.postContainer = document;\n        console.log('Using document as fallback container');\n    }\n    \n    // Check like status\n    status.isLiked = await checkLikeStatus(status.postContainer);\n    \n    // Check comment status  \n    status.hasCommented = await checkCommentStatus(status.postContainer, commentText);\n    \n    return status;\n}\n\n// Enhanced like status detection\nasync function checkLikeStatus(container) {\n    const likeSelectors = [\n        'button[aria-label*=\"Like\"][aria-pressed=\"true\"]',\n        'button[aria-label*=\"unlike\" i]', // \"Unlike\" indicates already liked\n        'button[aria-label*=\"Like\"].active',\n        'button[aria-label*=\"Like\"].selected',\n        'button.artdeco-button--primary[aria-label*=\"Like\"]',\n        '.social-action-bar button[aria-pressed=\"true\"][aria-label*=\"Like\"]'\n    ];\n    \n    for (const selector of likeSelectors) {\n        const likeButton = container.querySelector(selector);\n        if (likeButton) {\n            const ariaLabel = likeButton.getAttribute('aria-label') || '';\n            const ariaPressed = likeButton.getAttribute('aria-pressed');\n            \n            if (ariaPressed === 'true' || ariaLabel.toLowerCase().includes('unlike')) {\n                console.log('Post already liked by current user');\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Enhanced comment status detection - checks if current user has already commented\nasync function checkCommentStatus(container, commentText) {\n    const commentSelectors = [\n        '.comments-comment-item',\n        '.comments-comment-entity',\n        '.comment-entity', \n        '.feed-shared-comment',\n        '[data-test-id=\"comment\"]',\n        '.social-comment-entity'\n    ];\n    \n    // Get current user info to identify their comments\n    const currentUserInfo = await getCurrentUserInfo();\n    console.log('Current user info:', currentUserInfo);\n    \n    for (const selector of commentSelectors) {\n        const comments = container.querySelectorAll(selector);\n        console.log(`Checking ${comments.length} comments with selector: ${selector}`);\n        \n        for (const comment of comments) {\n            // Check if this comment is from the current user\n            if (isCommentByCurrentUser(comment, currentUserInfo)) {\n                console.log('Found comment by current user - skipping post');\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Get current user info from LinkedIn page\nasync function getCurrentUserInfo() {\n    const userInfo = {\n        profileUrl: null,\n        name: null,\n        miniProfileId: null\n    };\n    \n    // Try to find current user's profile link\n    const profileSelectors = [\n        'a.global-nav__primary-link-me-menu-trigger',\n        '.global-nav__me-photo',\n        '.global-nav__me img',\n        '[data-control-name=\"identity_profile_photo\"]',\n        'a[href*=\"/in/\"][href*=\"miniProfileUrn\"]'\n    ];\n    \n    for (const selector of profileSelectors) {\n        const element = document.querySelector(selector);\n        if (element) {\n            const link = element.closest('a');\n            if (link) {\n                userInfo.profileUrl = link.href;\n                // Extract mini profile ID from URL if present\n                const miniProfileMatch = link.href.match(/miniProfileUrn=([^&]+)/);\n                if (miniProfileMatch) {\n                    userInfo.miniProfileId = decodeURIComponent(miniProfileMatch[1]);\n                }\n                console.log('Found current user profile URL:', userInfo.profileUrl);\n                break;\n            }\n        }\n    }\n    \n    // Try to get user name from navigation\n    const nameElement = document.querySelector('.global-nav__me-content .t-16.t-black.t-bold, .global-nav__me-content span');\n    if (nameElement) {\n        userInfo.name = nameElement.textContent.trim();\n        console.log('Found current user name:', userInfo.name);\n    }\n    \n    return userInfo;\n}\n\n// Check if a comment was made by the current user\nfunction isCommentByCurrentUser(commentElement, currentUserInfo) {\n    // Method 1: Check for \"you\" indicator in comment\n    const youIndicators = commentElement.querySelectorAll('[aria-label*=\"You\"], .comments-post-meta__name-text a[aria-label*=\"You\"]');\n    if (youIndicators.length > 0) {\n        console.log('Found \"You\" indicator in comment');\n        return true;\n    }\n    \n    // Method 2: Check comment author's profile link\n    const authorLinkSelectors = [\n        '.comments-post-meta__profile-link',\n        '.comments-comment-item__main-content a[href*=\"/in/\"]',\n        '.comment-entity a[href*=\"/in/\"]',\n        'a.comment-author-link',\n        '.comments-post-meta__name-text a'\n    ];\n    \n    for (const selector of authorLinkSelectors) {\n        const authorLink = commentElement.querySelector(selector);\n        if (authorLink && currentUserInfo.profileUrl) {\n            const authorHref = authorLink.href;\n            \n            // Extract base profile URLs for comparison\n            const currentProfileBase = currentUserInfo.profileUrl.split('?')[0].split('/').filter(p => p).pop();\n            const authorProfileBase = authorHref.split('?')[0].split('/').filter(p => p).pop();\n            \n            if (currentProfileBase && authorProfileBase && currentProfileBase === authorProfileBase) {\n                console.log('Found comment by current user (profile URL match)');\n                return true;\n            }\n            \n            // Check mini profile ID if available\n            if (currentUserInfo.miniProfileId) {\n                const authorMiniProfileMatch = authorHref.match(/miniProfileUrn=([^&]+)/);\n                if (authorMiniProfileMatch) {\n                    const authorMiniProfileId = decodeURIComponent(authorMiniProfileMatch[1]);\n                    if (authorMiniProfileId === currentUserInfo.miniProfileId) {\n                        console.log('Found comment by current user (mini profile ID match)');\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Method 3: Check author name if available\n    if (currentUserInfo.name) {\n        const authorNameElement = commentElement.querySelector('.comments-post-meta__name-text, .comment-author-name');\n        if (authorNameElement) {\n            const authorName = authorNameElement.textContent.trim();\n            if (authorName === currentUserInfo.name || authorName.includes(currentUserInfo.name)) {\n                console.log('Found comment by current user (name match)');\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\n// Extract text content from comment element\nfunction extractCommentText(commentElement) {\n    const contentSelectors = [\n        '.comment-content',\n        '.comments-comment-item-content-text',\n        '.feed-shared-text',\n        '[data-test-id=\"comment-content\"]',\n        '.comment-text'\n    ];\n    \n    for (const selector of contentSelectors) {\n        const contentEl = commentElement.querySelector(selector);\n        if (contentEl) {\n            return contentEl.textContent || contentEl.innerText || '';\n        }\n    }\n    \n    // Fallback to full element text\n    return commentElement.textContent || commentElement.innerText || '';\n}\n\n// Implement strict idempotency matrix with action preferences\nasync function processAccordingToMatrix(currentStatus, commentText, dryRun = false, enableLike = true, enableComment = true) {\n    const result = {\n        liked: false,\n        commented: false,\n        skipped: false,\n        status: '',\n        reason: ''\n    };\n    \n    console.log('Processing according to matrix:', currentStatus);\n    console.log('Action preferences:', { enableLike, enableComment });\n    \n    // Determine what actions to attempt based on preferences and current status\n    const shouldAttemptLike = enableLike && !currentStatus.isLiked;\n    const shouldAttemptComment = enableComment && !currentStatus.hasCommented;\n    \n    // Check if post should be skipped entirely\n    if ((!enableLike || currentStatus.isLiked) && (!enableComment || currentStatus.hasCommented)) {\n        console.log('Post should be skipped based on preferences and current status');\n        result.skipped = true;\n        \n        if (!enableLike && !enableComment) {\n            result.status = 'skipped (no actions enabled)';\n            result.reason = 'no_actions_enabled';\n        } else if (currentStatus.isLiked && currentStatus.hasCommented) {\n            result.status = 'already liked and commented';\n            result.reason = 'already_processed';\n        } else if (currentStatus.isLiked && !enableComment) {\n            result.status = 'already liked (commenting disabled)';\n            result.reason = 'already_liked_commenting_disabled';\n        } else if (currentStatus.hasCommented && !enableLike) {\n            result.status = 'already commented (liking disabled)';\n            result.reason = 'already_commented_liking_disabled';\n        } else {\n            result.status = 'skipped';\n            result.reason = 'conditions_not_met';\n        }\n        \n        return result;\n    }\n    \n    if (dryRun) {\n        // Dry-run mode: simulate actions without actually performing them\n        console.log('DRY-RUN MODE: Simulating actions based on matrix and preferences');\n        \n        if (shouldAttemptLike && shouldAttemptComment) {\n            result.liked = true; \n            result.commented = true;\n            result.status = 'would like and comment (simulated)';\n        } else if (shouldAttemptLike) {\n            result.liked = true;\n            result.status = 'would like (simulated)';\n        } else if (shouldAttemptComment) {\n            result.commented = true;\n            result.status = 'would comment (simulated)';\n        }\n        \n    } else {\n        // Normal operation mode\n        const actions = [];\n        \n        if (shouldAttemptLike) {\n            console.log('Attempting to like post...');\n            const likeResult = await performLike(currentStatus.postContainer);\n            result.liked = likeResult.success;\n            actions.push(likeResult.message);\n        }\n        \n        if (shouldAttemptComment) {\n            console.log('Attempting to comment on post...');\n            const commentResult = await performComment(currentStatus.postContainer, commentText);\n            result.commented = commentResult.success;\n            actions.push(commentResult.message);\n        }\n        \n        result.status = actions.join(' ').trim();\n        \n        // Add reason if some actions were already done\n        if (enableLike && currentStatus.isLiked && !enableComment) {\n            result.reason = 'already_liked';\n        } else if (enableComment && currentStatus.hasCommented && !enableLike) {\n            result.reason = 'already_commented';\n        } else if (currentStatus.isLiked && !shouldAttemptLike) {\n            result.reason = 'already_liked';\n        } else if (currentStatus.hasCommented && !shouldAttemptComment) {\n            result.reason = 'already_commented';\n        }\n    }\n    \n    return result;\n}\n\nasync function waitForLinkedInPage() {\n    // Try multiple selectors for different LinkedIn page types\n    const pageSelectors = [\n        '[data-test-id=\"feed-shared-update-v2\"]', // Feed posts\n        '.feed-shared-update-v2',                 // Alternative feed posts\n        '.share-update-v2',                       // Individual posts\n        '.single-post-view',                      // Single post page\n        '[data-urn*=\"activity:\"]',                // Activity containers\n        '.activity-content',                      // Activity content\n        '.social-action-bar',                     // Action bar with like/comment buttons\n        'main[role=\"main\"]'                       // Main content area\n    ];\n    \n    console.log('Trying to find LinkedIn page elements...');\n    \n    for (const selector of pageSelectors) {\n        try {\n            console.log('Trying selector:', selector);\n            await waitForElement(selector, 2000);\n            console.log('Found element with selector:', selector);\n            return;\n        } catch (e) {\n            console.log('Selector not found:', selector);\n        }\n    }\n    \n    // If no specific selectors work, just wait a bit for page to settle\n    console.log('No specific LinkedIn elements found, waiting for page to settle...');\n    await sleep(3000);\n}\n\n\nasync function tryCommentPost(commentText) {\n    try {\n        // Comprehensive comment button selectors for current LinkedIn\n        const commentSelectors = [\n            // Primary comment button patterns\n            'button[aria-label*=\"Comment\"]',\n            'button[aria-label*=\"comment\"]',\n            'button[aria-label*=\"Add a comment\"]',\n            '[data-control-name=\"comment\"]',\n            \n            // Specific LinkedIn patterns\n            '.social-actions-bar button[aria-label*=\"Comment\"]',\n            '.social-action-bar button[aria-label*=\"Comment\"]',\n            'button[data-test-id=\"comment-button\"]',\n            'button.artdeco-button[aria-label*=\"Comment\"]',\n            \n            // SVG-based comment buttons\n            'button:has(svg[data-test-id=\"comment-outline-medium\"])',\n            'button:has(svg[data-test-id=\"comment-filled-medium\"])',\n            \n            // Fallback patterns\n            'button[title*=\"Comment\"]',\n            '.comment-button',\n            '[data-tracking-control-name*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment button...');\n        let commentButton = null;\n        \n        for (const selector of commentSelectors) {\n            try {\n                console.log('Trying comment selector:', selector);\n                const buttons = document.querySelectorAll(selector);\n                console.log(`Found ${buttons.length} elements for selector:`, selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    console.log('Comment button details:', {\n                        selector,\n                        ariaLabel,\n                        textContent: button.textContent.trim(),\n                        className: button.className\n                    });\n                    \n                    if (ariaLabel && ariaLabel.toLowerCase().includes('comment')) {\n                        commentButton = button;\n                        console.log('Found comment button:', button);\n                        break;\n                    }\n                }\n                if (commentButton) break;\n            } catch (e) {\n                console.log('Error with comment selector:', selector, e);\n            }\n        }\n        \n        if (!commentButton) {\n            console.log('Comment button not found. Available buttons:');\n            const allButtons = document.querySelectorAll('button');\n            for (let i = 0; i < Math.min(allButtons.length, 15); i++) {\n                const btn = allButtons[i];\n                console.log(`Button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    className: btn.className\n                });\n            }\n            return 'comment button not found';\n        }\n        \n        console.log('Clicking comment button...');\n        commentButton.click();\n        await sleep(2000); // Wait for comment box to appear\n        \n        // Look for comment input with comprehensive selectors\n        const commentInputSelectors = [\n            // Primary comment input patterns\n            '[contenteditable=\"true\"][aria-label*=\"comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Add a comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Write a comment\"]',\n            '[contenteditable=\"true\"][aria-label*=\"Share your thoughts\"]',\n            '[contenteditable=\"true\"][placeholder*=\"comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"Add a comment\"]',\n            '[contenteditable=\"true\"][placeholder*=\"Write a comment\"]',\n            \n            // Modern LinkedIn specific patterns\n            '.comments-comment-box__form [contenteditable=\"true\"]',\n            '.comments-comment-box-comment__form [contenteditable=\"true\"]',\n            '.comment-form__text-editor [contenteditable=\"true\"]',\n            '.comment-box__form [contenteditable=\"true\"]',\n            '.ql-editor[contenteditable=\"true\"]', // Quill editor\n            '[role=\"textbox\"][contenteditable=\"true\"]',\n            '.comments-comment-texteditor [contenteditable=\"true\"]',\n            '.comment-compose-form [contenteditable=\"true\"]',\n            \n            // Data attribute patterns\n            '[data-test-id*=\"comment\"][contenteditable=\"true\"]',\n            '[data-control-name*=\"comment\"][contenteditable=\"true\"]',\n            '[data-placeholder*=\"comment\"][contenteditable=\"true\"]',\n            \n            // Fallback patterns\n            'div[contenteditable=\"true\"]',\n            'textarea[aria-label*=\"comment\"]',\n            'textarea[placeholder*=\"comment\"]'\n        ];\n        \n        console.log('Searching for comment input...');\n        let commentInput = null;\n        \n        for (const selector of commentInputSelectors) {\n            try {\n                console.log('Trying comment input selector:', selector);\n                const inputs = document.querySelectorAll(selector);\n                console.log(`Found ${inputs.length} comment inputs for selector:`, selector);\n                \n                for (const input of inputs) {\n                    if (input.offsetHeight > 0 && input.offsetWidth > 0) { // Check if visible\n                        commentInput = input;\n                        console.log('Found visible comment input:', input);\n                        break;\n                    }\n                }\n                if (commentInput) break;\n            } catch (e) {\n                console.log('Error with comment input selector:', selector, e);\n            }\n        }\n        \n        if (!commentInput) {\n            console.log('Comment input not found. Available contenteditable elements:');\n            const editables = document.querySelectorAll('[contenteditable=\"true\"]');\n            for (let i = 0; i < Math.min(editables.length, 10); i++) {\n                const elem = editables[i];\n                console.log(`Editable ${i}:`, {\n                    ariaLabel: elem.getAttribute('aria-label'),\n                    placeholder: elem.getAttribute('placeholder'),\n                    className: elem.className,\n                    visible: elem.offsetHeight > 0 && elem.offsetWidth > 0\n                });\n            }\n            return 'comment input not found';\n        }\n        \n        \n        // Add comment text using enhanced method\n        console.log('Adding comment text...');\n        await addCommentText(commentInput, commentText);\n        \n        await sleep(1500);\n        \n        // Find the comment container to scope our submit button search\n        const commentContainer = commentInput.closest('.comments-comment-box, .comment-compose-form, .comment-form, .comments-comment-entity, form') || document;\n        \n        // Look for submit/post button with comprehensive selectors (scoped to comment container)\n        const submitSelectors = [\n            // Primary comment submit patterns\n            'button[aria-label*=\"Post comment\"]',\n            'button[aria-label*=\"Post your comment\"]',\n            'button[aria-label*=\"Submit comment\"]',\n            'button[aria-label*=\"Post\"]',\n            'button[data-control-name=\"comment.post\"]',\n            'button[data-control-name*=\"comment_submit\"]',\n            'button[data-control-name*=\"comment\"]',\n            \n            // Form and container-based selectors\n            'button[type=\"submit\"]',\n            '.comment-compose-form button[type=\"submit\"]',\n            '.comments-comment-box button[aria-label*=\"Post\"]',\n            '.comments-comment-entity button',\n            '.comments-comment-item button',\n            \n            // Modern LinkedIn UI patterns\n            'button.artdeco-button--primary',\n            'button.comments-comment-box__submit-button',\n            'button.comment-form__submit-button',\n            '.comment-form button[aria-label*=\"Post\"]',\n            '.comment-box button[aria-label*=\"Post\"]',\n            \n            // Generic button patterns near comment areas\n            'button:has(span:contains(\"Post\"))',\n            'button:has([data-control-name*=\"comment\"])',\n            '[data-test-id*=\"comment\"] button',\n            \n            // Backup patterns\n            'button[aria-label*=\"Share\"]',\n            'button.artdeco-button[aria-label*=\"comment\"]'\n        ];\n        \n        console.log('Searching for submit button...');\n        let submitButton = null;\n        \n        for (const selector of submitSelectors) {\n            try {\n                console.log('Trying submit selector:', selector);\n                const buttons = commentContainer.querySelectorAll(selector);\n                \n                for (const button of buttons) {\n                    const ariaLabel = button.getAttribute('aria-label');\n                    const textContent = button.textContent.toLowerCase().trim();\n                    const dataControlName = button.getAttribute('data-control-name');\n                    \n                    // Check multiple criteria for submit buttons\n                    const isSubmitButton = (\n                        (ariaLabel && (\n                            ariaLabel.toLowerCase().includes('post') ||\n                            ariaLabel.toLowerCase().includes('submit') ||\n                            ariaLabel.toLowerCase().includes('comment')\n                        )) ||\n                        (textContent && (\n                            textContent.includes('post') || \n                            textContent.includes('submit') ||\n                            textContent === 'post'\n                        )) ||\n                        (dataControlName && dataControlName.includes('comment')) ||\n                        button.type === 'submit'\n                    );\n                    \n                    // Also check if button is visible and enabled\n                    const isVisible = button.offsetParent !== null;\n                    const isEnabled = !button.disabled && !button.hasAttribute('disabled') && !button.getAttribute('aria-disabled');\n                    const computedStyle = window.getComputedStyle(button);\n                    const isStyleVisible = computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden';\n                    \n                    if (isSubmitButton && isVisible && isEnabled && isStyleVisible) {\n                        submitButton = button;\n                        console.log('Found submit button:', {\n                            ariaLabel,\n                            textContent,\n                            dataControlName,\n                            visible: isVisible,\n                            enabled: isEnabled,\n                            element: button\n                        });\n                        break;\n                    }\n                }\n                if (submitButton) break;\n            } catch (e) {\n                console.log('Error with submit selector:', selector, e);\n            }\n        }\n        \n        if (submitButton && !submitButton.disabled && !submitButton.getAttribute('disabled')) {\n            console.log('Clicking submit button...');\n            submitButton.click();\n            await sleep(3000); // Wait for comment to post\n            return 'commented';\n        } else {\n            console.log('Submit button not found or disabled. Available buttons near comment:');\n            const nearbyButtons = commentInput.closest('form, .comment-compose-form, .comments-comment-box')?.querySelectorAll('button') || [];\n            for (let i = 0; i < nearbyButtons.length; i++) {\n                const btn = nearbyButtons[i];\n                console.log(`Nearby button ${i}:`, {\n                    ariaLabel: btn.getAttribute('aria-label'),\n                    textContent: btn.textContent.trim(),\n                    disabled: btn.disabled,\n                    className: btn.className\n                });\n            }\n            return 'submit button not found or disabled';\n        }\n    } catch (error) {\n        console.error('Error commenting on post:', error);\n        return 'comment failed: ' + error.message;\n    }\n}\n\n// Perform like action with enhanced detection and error handling\nasync function performLike(container) {\n    const result = { success: false, message: 'like failed' };\n    \n    const likeSelectors = [\n        'button[aria-label*=\"Like\"][aria-pressed=\"false\"]',\n        'button[aria-label*=\"Like\"]:not([aria-pressed=\"true\"])',\n        'button[aria-label*=\"React Like\"]',\n        '[data-control-name=\"like\"]:not(.active)',\n        '.social-actions-bar button[aria-label*=\"Like\"]',\n        '.social-action-bar button[aria-label*=\"Like\"]',\n        'button.artdeco-button[aria-label*=\"Like\"]:not(.artdeco-button--primary)'\n    ];\n    \n    for (const selector of likeSelectors) {\n        try {\n            const buttons = container.querySelectorAll(selector);\n            \n            for (const button of buttons) {\n                const ariaLabel = button.getAttribute('aria-label') || '';\n                const ariaPressed = button.getAttribute('aria-pressed');\n                \n                // Make sure this is an unliked like button\n                if (ariaLabel.toLowerCase().includes('like') && \n                    ariaPressed !== 'true' && \n                    !ariaLabel.toLowerCase().includes('unlike') &&\n                    button.offsetParent !== null) { // Check visibility\n                    \n                    console.log('Clicking like button:', button);\n                    button.click();\n                    \n                    // Wait and verify like was successful\n                    await sleep(2000);\n                    \n                    // Check if button state changed to indicate successful like\n                    const newAriaPressed = button.getAttribute('aria-pressed');\n                    const newAriaLabel = button.getAttribute('aria-label') || '';\n                    \n                    if (newAriaPressed === 'true' || newAriaLabel.toLowerCase().includes('unlike')) {\n                        result.success = true;\n                        result.message = 'liked';\n                        console.log('Like successful - button state changed');\n                        return result;\n                    }\n                }\n            }\n        } catch (e) {\n            console.log('Error with like selector:', selector, e);\n        }\n    }\n    \n    result.message = 'like button not found';\n    return result;\n}\n\n// Perform comment action with enhanced detection and error handling\nasync function performComment(container, commentText) {\n    const result = { success: false, message: 'comment failed' };\n    \n    try {\n        // First, find and click comment button\n        const commentButton = await findCommentButton(container);\n        if (!commentButton) {\n            result.message = 'comment button not found';\n            return result;\n        }\n        \n        console.log('Clicking comment button...');\n        commentButton.click();\n        await sleep(2000);\n        \n        // Find comment input\n        const commentInput = await findCommentInput(container);\n        if (!commentInput) {\n            result.message = 'comment input not found';\n            return result;\n        }\n        \n        // Add comment text\n        console.log('Adding comment text...');\n        await addCommentText(commentInput, commentText);\n        await sleep(1500);\n        \n        // Find and click submit button\n        const submitButton = await findSubmitButton(container, commentInput);\n        if (!submitButton) {\n            result.message = 'submit button not found';\n            return result;\n        }\n        \n        console.log('Clicking submit button...');\n        submitButton.click();\n        await sleep(3000);\n        \n        result.success = true;\n        result.message = 'commented';\n        return result;\n        \n    } catch (error) {\n        console.error('Error in performComment:', error);\n        result.message = `comment error: ${error.message}`;\n        return result;\n    }\n}\n\n// Find comment button with enhanced selectors\nasync function findCommentButton(container) {\n    const commentSelectors = [\n        'button[aria-label*=\"Comment\"]',\n        'button[aria-label*=\"Add a comment\"]',\n        'button[data-control-name=\"comment\"]',\n        '.social-actions-bar button[aria-label*=\"Comment\"]',\n        '.social-action-bar button[aria-label*=\"Comment\"]',\n        'button:has(svg[data-test-id=\"comment-outline-medium\"])'\n    ];\n    \n    for (const selector of commentSelectors) {\n        try {\n            const buttons = container.querySelectorAll(selector);\n            for (const button of buttons) {\n                const ariaLabel = button.getAttribute('aria-label') || '';\n                if (ariaLabel.toLowerCase().includes('comment') && button.offsetParent !== null) {\n                    return button;\n                }\n            }\n        } catch (e) {\n            console.log('Error with comment button selector:', selector, e);\n        }\n    }\n    \n    return null;\n}\n\n// Find comment input with enhanced selectors\nasync function findCommentInput(container) {\n    // Wait for input to appear after clicking comment button\n    await sleep(1000);\n    \n    const inputSelectors = [\n        '[contenteditable=\"true\"][aria-label*=\"comment\"]',\n        '[contenteditable=\"true\"][placeholder*=\"comment\"]',\n        '.comments-comment-box__form [contenteditable=\"true\"]',\n        '.comment-form__text-editor [contenteditable=\"true\"]',\n        '.ql-editor[contenteditable=\"true\"]',\n        '[role=\"textbox\"][contenteditable=\"true\"]',\n        'div[contenteditable=\"true\"]:not([aria-label*=\"search\"])'\n    ];\n    \n    for (const selector of inputSelectors) {\n        try {\n            const inputs = container.querySelectorAll(selector);\n            for (const input of inputs) {\n                if (input.offsetParent !== null) { // Check visibility\n                    return input;\n                }\n            }\n        } catch (e) {\n            console.log('Error with input selector:', selector, e);\n        }\n    }\n    \n    return null;\n}\n\n// Find submit button with enhanced selectors\nasync function findSubmitButton(container, inputElement) {\n    const inputContainer = inputElement.closest('.comments-comment-box, .comment-compose-form, .comment-form, form') || container;\n    \n    const submitSelectors = [\n        'button[aria-label*=\"Post comment\"]',\n        'button[aria-label*=\"Post your comment\"]', \n        'button[type=\"submit\"]',\n        'button.artdeco-button--primary',\n        '.comment-form__submit-button',\n        'button[data-control-name*=\"comment\"]'\n    ];\n    \n    for (const selector of submitSelectors) {\n        try {\n            const buttons = inputContainer.querySelectorAll(selector);\n            for (const button of buttons) {\n                const ariaLabel = button.getAttribute('aria-label') || '';\n                const textContent = button.textContent.toLowerCase().trim();\n                \n                const isSubmitButton = (\n                    ariaLabel.toLowerCase().includes('post') ||\n                    textContent.includes('post') ||\n                    button.type === 'submit'\n                );\n                \n                if (isSubmitButton && button.offsetParent !== null && !button.disabled) {\n                    return button;\n                }\n            }\n        } catch (e) {\n            console.log('Error with submit selector:', selector, e);\n        }\n    }\n    \n    return null;\n}\n\n// Enhanced comment text insertion\nasync function addCommentText(commentInput, commentText) {\n    commentInput.focus();\n    \n    // Clear existing content\n    commentInput.innerHTML = '';\n    commentInput.textContent = '';\n    \n    if (commentInput.contentEditable === 'true') {\n        // For contenteditable elements\n        const textNode = document.createTextNode(commentText);\n        commentInput.appendChild(textNode);\n        \n        // Trigger comprehensive events\n        const events = [\n            new Event('focus', { bubbles: true }),\n            new Event('beforeinput', { bubbles: true, cancelable: true }),\n            new InputEvent('input', { bubbles: true, cancelable: true, inputType: 'insertText', data: commentText }),\n            new Event('change', { bubbles: true }),\n            new Event('keyup', { bubbles: true })\n        ];\n        \n        for (const event of events) {\n            commentInput.dispatchEvent(event);\n        }\n    } else {\n        // For regular input elements\n        commentInput.value = commentText;\n        \n        const events = [\n            new Event('focus', { bubbles: true }),\n            new Event('input', { bubbles: true }),\n            new Event('change', { bubbles: true })\n        ];\n        \n        for (const event of events) {\n            commentInput.dispatchEvent(event);\n        }\n    }\n    \n    // Final cursor positioning\n    if (window.getSelection && document.createRange) {\n        const range = document.createRange();\n        const selection = window.getSelection();\n        if (commentInput.childNodes.length > 0) {\n            range.setStartAfter(commentInput.childNodes[commentInput.childNodes.length - 1]);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    }\n}\n\nfunction waitForElement(selector, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const element = document.querySelector(selector);\n        if (element) {\n            resolve(element);\n            return;\n        }\n        \n        const observer = new MutationObserver((mutations) => {\n            const element = document.querySelector(selector);\n            if (element) {\n                observer.disconnect();\n                resolve(element);\n            }\n        });\n        \n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n        \n        setTimeout(() => {\n            observer.disconnect();\n            reject(new Error(`Element ${selector} not found within ${timeout}ms`));\n        }, timeout);\n    });\n}\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Helper function to calculate text similarity\nfunction calculateSimilarity(str1, str2) {\n    if (str1 === str2) return 1.0;\n    if (str1.length === 0 || str2.length === 0) return 0.0;\n    \n    // Simple similarity based on common words and character overlap\n    const words1 = str1.split(/\\s+/).filter(w => w.length > 2);\n    const words2 = str2.split(/\\s+/).filter(w => w.length > 2);\n    \n    if (words1.length === 0 || words2.length === 0) {\n        // Character-based similarity for short texts\n        const longer = str1.length > str2.length ? str1 : str2;\n        const shorter = str1.length > str2.length ? str2 : str1;\n        const editDistance = levenshteinDistance(longer, shorter);\n        return (longer.length - editDistance) / longer.length;\n    }\n    \n    const commonWords = words1.filter(w => words2.includes(w));\n    const totalWords = Math.max(words1.length, words2.length);\n    \n    return commonWords.length / totalWords;\n}\n\n// Simple Levenshtein distance calculation\nfunction levenshteinDistance(str1, str2) {\n    const matrix = [];\n    \n    for (let i = 0; i <= str2.length; i++) {\n        matrix[i] = [i];\n    }\n    \n    for (let j = 0; j <= str1.length; j++) {\n        matrix[0][j] = j;\n    }\n    \n    for (let i = 1; i <= str2.length; i++) {\n        for (let j = 1; j <= str1.length; j++) {\n            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            } else {\n                matrix[i][j] = Math.min(\n                    matrix[i - 1][j - 1] + 1,\n                    matrix[i][j - 1] + 1,\n                    matrix[i - 1][j] + 1\n                );\n            }\n        }\n    }\n    \n    return matrix[str2.length][str1.length];\n}\n\n// Log when content script loads\nconsole.log('LinkedIn Auto Commenter content script loaded');","size_bytes":40932},"chrome-extension/popup.js":{"content":"document.addEventListener('DOMContentLoaded', function() {\n    // Get DOM elements\n    const commentText = document.getElementById('commentText');\n    const textInput = document.getElementById('textInput');\n    const minDelay = document.getElementById('minDelay');\n    const maxDelay = document.getElementById('maxDelay');\n    const urlTimeout = document.getElementById('urlTimeout');\n    const retryLimit = document.getElementById('retryLimit');\n    const dryRunCheckbox = document.getElementById('dryRun');\n    const enableLikeCheckbox = document.getElementById('enableLike');\n    const enableCommentCheckbox = document.getElementById('enableComment');\n    \n    const startBtn = document.getElementById('startBtn');\n    const pauseBtn = document.getElementById('pauseBtn');\n    const stopBtn = document.getElementById('stopBtn');\n    const exportBtn = document.getElementById('exportBtn');\n    \n    const status = document.getElementById('status');\n    const currentUrlDisplay = document.getElementById('currentUrl');\n    const progressBar = document.getElementById('progressBar');\n    const progressText = document.getElementById('progressText');\n    const counters = document.getElementById('counters');\n    const extractedUrls = document.getElementById('extractedUrls');\n    \n    const activityLog = document.getElementById('activityLog');\n    const logContent = document.getElementById('logContent');\n    const logFilterButtons = document.getElementById('logFilterButtons');\n    const clearLogBtn = document.getElementById('clearLogBtn');\n    const exportLogBtn = document.getElementById('exportLogBtn');\n    \n    const userInfo = document.getElementById('userInfo');\n\n    // State variables\n    let isRunning = false;\n    let isPaused = false;\n    let currentUrls = [];\n    let currentIndex = 0;\n    let automationState = null;\n    let logFilter = 'all'; // all, info, success, error, warning\n    let allLogs = [];\n\n    // Load saved data\n    loadSavedData();\n\n    // Set up event listeners\n    setupEventListeners();\n\n    // Check automation status on popup open\n    checkAutomationStatus();\n\n    // Get LinkedIn user info\n    getLinkedInUserInfo();\n\n    function loadSavedData() {\n        chrome.storage.sync.get([\n            'commentText', 'textInput', 'minDelay', 'maxDelay', \n            'urlTimeout', 'retryLimit', 'dryRun', 'enableLike', 'enableComment'\n        ], function(data) {\n            if (data.commentText) commentText.value = data.commentText;\n            if (data.textInput) {\n                textInput.value = data.textInput;\n                extractLinkedInUrls();\n            }\n            minDelay.value = data.minDelay || 2;\n            maxDelay.value = data.maxDelay || 5;\n            urlTimeout.value = data.urlTimeout || 30;\n            retryLimit.value = data.retryLimit || 2;\n            dryRunCheckbox.checked = data.dryRun || false;\n            enableLikeCheckbox.checked = data.enableLike !== false;\n            enableCommentCheckbox.checked = data.enableComment !== false;\n        });\n    }\n\n    function setupEventListeners() {\n        // Input event listeners with data persistence\n        commentText.addEventListener('input', () => {\n            chrome.storage.sync.set({commentText: commentText.value});\n        });\n\n        textInput.addEventListener('input', () => {\n            chrome.storage.sync.set({textInput: textInput.value});\n            extractLinkedInUrls();\n        });\n\n        minDelay.addEventListener('input', () => {\n            chrome.storage.sync.set({minDelay: minDelay.value});\n        });\n\n        maxDelay.addEventListener('input', () => {\n            chrome.storage.sync.set({maxDelay: maxDelay.value});\n        });\n\n        urlTimeout.addEventListener('input', () => {\n            chrome.storage.sync.set({urlTimeout: urlTimeout.value});\n        });\n\n        retryLimit.addEventListener('input', () => {\n            chrome.storage.sync.set({retryLimit: retryLimit.value});\n        });\n\n        dryRunCheckbox.addEventListener('change', () => {\n            chrome.storage.sync.set({dryRun: dryRunCheckbox.checked});\n        });\n\n        enableLikeCheckbox.addEventListener('change', () => {\n            chrome.storage.sync.set({enableLike: enableLikeCheckbox.checked});\n        });\n\n        enableCommentCheckbox.addEventListener('change', () => {\n            chrome.storage.sync.set({enableComment: enableCommentCheckbox.checked});\n        });\n\n        // Control button listeners\n        startBtn.addEventListener('click', startAutomation);\n        pauseBtn.addEventListener('click', pauseAutomation);\n        stopBtn.addEventListener('click', stopAutomation);\n        exportBtn.addEventListener('click', exportData);\n\n        // Log control listeners\n        clearLogBtn.addEventListener('click', clearLogs);\n        exportLogBtn.addEventListener('click', exportLogs);\n\n        // Log filter buttons\n        document.querySelectorAll('.filter-btn').forEach(btn => {\n            btn.addEventListener('click', (e) => {\n                setLogFilter(e.target.dataset.filter);\n            });\n        });\n\n        // Current URL click handler\n        currentUrlDisplay.addEventListener('click', openCurrentUrl);\n    }\n\n    function extractLinkedInUrls() {\n        const text = textInput.value;\n        const urlRegex = /https?:\\/\\/(?:(?:www\\.)?linkedin\\.com\\/(?:posts|feed\\/update|in)\\/[^\\s\\]]+|lnkd\\.in\\/[^\\s\\]]+)/gi;\n        const urls = text.match(urlRegex) || [];\n        \n        const cleanUrls = urls.map(url => url.replace(/[,.\\])\\s]*$/, '').trim());\n        const uniqueUrls = [...new Set(cleanUrls)];\n        currentUrls = uniqueUrls;\n        \n        if (uniqueUrls.length > 0) {\n            extractedUrls.innerHTML = `\n                <strong>Found ${uniqueUrls.length} LinkedIn URLs:</strong><br>\n                ${uniqueUrls.map((url, index) => `\n                    <div class=\"url-item\">\n                        <span class=\"url-index\">${index + 1}.</span>\n                        <span class=\"url-text\" title=\"${url}\">${url.length > 50 ? url.substring(0, 50) + '...' : url}</span>\n                    </div>\n                `).join('')}\n            `;\n        } else {\n            extractedUrls.innerHTML = '<span class=\"no-urls\">No LinkedIn URLs found in the text.</span>';\n        }\n    }\n\n    function startAutomation() {\n        const comment = commentText.value.trim();\n        const minDelayVal = parseInt(minDelay.value) || 2;\n        const maxDelayVal = parseInt(maxDelay.value) || 5;\n        const urlTimeoutVal = parseInt(urlTimeout.value) || 30;\n        const retryLimitVal = parseInt(retryLimit.value) || 2;\n        const isDryRun = dryRunCheckbox.checked;\n        const shouldLike = enableLikeCheckbox.checked;\n        const shouldComment = enableCommentCheckbox.checked;\n\n        // Validation\n        if (!shouldLike && !shouldComment) {\n            updateStatus('Please select at least one action: Like or Comment', 'error');\n            return;\n        }\n\n        if (!comment && shouldComment && !isDryRun) {\n            updateStatus('Please enter a comment text or disable commenting', 'error');\n            return;\n        }\n\n        if (currentUrls.length === 0) {\n            updateStatus('Please add text with LinkedIn URLs', 'error');\n            return;\n        }\n\n        if (minDelayVal > maxDelayVal) {\n            updateStatus('Min delay cannot be greater than max delay', 'error');\n            return;\n        }\n\n        // Start automation\n        currentIndex = 0;\n        isRunning = true;\n        isPaused = false;\n\n        updateUIForRunning();\n        updateStatus('Starting automation...', 'running');\n        updateCounters(0, 0, 0, 0);\n        \n        addLogEntry(`Started automation with ${currentUrls.length} URLs`, 'success');\n        addLogEntry(`Settings: ${minDelayVal}-${maxDelayVal}s delay, ${urlTimeoutVal}s timeout, ${retryLimitVal} retries${isDryRun ? ', DRY-RUN MODE' : ''}`, 'info');\n\n        // Send message to background script\n        chrome.runtime.sendMessage({\n            action: 'startAutomation',\n            comment: comment,\n            urls: currentUrls,\n            minDelay: minDelayVal,\n            maxDelay: maxDelayVal,\n            urlTimeout: urlTimeoutVal,\n            retryLimit: retryLimitVal,\n            dryRun: isDryRun,\n            enableLike: shouldLike,\n            enableComment: shouldComment\n        });\n    }\n\n    function pauseAutomation() {\n        if (isPaused) {\n            // Resume\n            chrome.runtime.sendMessage({action: 'resumeAutomation'});\n            isPaused = false;\n            pauseBtn.textContent = 'Pause';\n            updateStatus('Automation resumed', 'running');\n            addLogEntry('Automation resumed', 'info');\n        } else {\n            // Pause\n            chrome.runtime.sendMessage({action: 'pauseAutomation'});\n            isPaused = true;\n            pauseBtn.textContent = 'Resume';\n            updateStatus('Automation paused', 'paused');\n            addLogEntry('Automation paused', 'warning');\n        }\n    }\n\n    function stopAutomation() {\n        chrome.runtime.sendMessage({action: 'stopAutomation'});\n        resetUI();\n        updateStatus('Automation stopped', 'idle');\n        updateProgress('');\n        addLogEntry('Automation stopped by user', 'warning');\n    }\n\n    function exportData() {\n        if (!automationState) {\n            addLogEntry('No automation data to export', 'warning');\n            return;\n        }\n\n        const data = {\n            urls: currentUrls,\n            stats: automationState.stats,\n            settings: {\n                comment: commentText.value,\n                minDelay: minDelay.value,\n                maxDelay: maxDelay.value,\n                urlTimeout: urlTimeout.value,\n                retryLimit: retryLimit.value,\n                dryRun: dryRunCheckbox.checked\n            },\n            timestamp: new Date().toISOString()\n        };\n\n        downloadJSON(data, `linkedin-automation-${Date.now()}.json`);\n        addLogEntry('Automation data exported', 'success');\n    }\n\n    function checkAutomationStatus() {\n        chrome.runtime.sendMessage({action: 'getStatus'}, function(state) {\n            if (state && state.isRunning) {\n                automationState = state;\n                currentUrls = state.urls;\n                currentIndex = state.currentIndex;\n                isRunning = true;\n                isPaused = state.isPaused || false;\n                \n                updateUIForRunning();\n                updateProgress(state.stats);\n                updateCurrentUrl(state.currentUrl);\n                \n                if (isPaused) {\n                    pauseBtn.textContent = 'Resume';\n                    updateStatus('Automation paused', 'paused');\n                } else {\n                    updateStatus(`Running: ${currentIndex + 1}/${currentUrls.length} posts`, 'running');\n                }\n\n                // Load recent logs\n                if (state.recentLogs) {\n                    state.recentLogs.forEach(log => {\n                        addLogEntry(log.message, log.type, false);\n                    });\n                }\n            }\n        });\n    }\n\n    function getLinkedInUserInfo() {\n        // This would need to be implemented based on how we can access LinkedIn user info\n        // For now, show a placeholder\n        userInfo.innerHTML = `\n            <div class=\"user-placeholder\">\n                <div class=\"user-avatar\">👤</div>\n                <div class=\"user-details\">\n                    <div class=\"user-name\">LinkedIn User</div>\n                    <div class=\"user-status\">Connected</div>\n                </div>\n            </div>\n        `;\n    }\n\n    function updateUIForRunning() {\n        startBtn.style.display = 'none';\n        pauseBtn.style.display = 'inline-block';\n        stopBtn.style.display = 'inline-block';\n        activityLog.style.display = 'block';\n        \n        // Disable form inputs during automation\n        commentText.disabled = true;\n        textInput.disabled = true;\n        minDelay.disabled = true;\n        maxDelay.disabled = true;\n        urlTimeout.disabled = true;\n        retryLimit.disabled = true;\n        dryRunCheckbox.disabled = true;\n    }\n\n    function resetUI() {\n        isRunning = false;\n        isPaused = false;\n        startBtn.style.display = 'inline-block';\n        pauseBtn.style.display = 'none';\n        stopBtn.style.display = 'none';\n        pauseBtn.textContent = 'Pause';\n        \n        // Re-enable form inputs\n        commentText.disabled = false;\n        textInput.disabled = false;\n        minDelay.disabled = false;\n        maxDelay.disabled = false;\n        urlTimeout.disabled = false;\n        retryLimit.disabled = false;\n        dryRunCheckbox.disabled = false;\n        \n        updateCurrentUrl('');\n        updateProgress({ processed: 0, total: 0, liked: 0, commented: 0, skipped: 0, failed: 0 });\n    }\n\n    function updateStatus(text, type) {\n        status.textContent = text;\n        status.className = `status ${type}`;\n    }\n\n    function updateProgress(stats) {\n        if (!stats || typeof stats !== 'object') {\n            progressBar.style.width = '0%';\n            progressText.textContent = '';\n            return;\n        }\n\n        const { processed = 0, total = 0, liked = 0, commented = 0, skipped = 0, failed = 0 } = stats;\n        \n        const progressPercent = total > 0 ? (processed / total) * 100 : 0;\n        progressBar.style.width = `${progressPercent}%`;\n        progressText.textContent = `${processed}/${total} posts processed`;\n        \n        updateCounters(liked, commented, skipped, failed);\n    }\n\n    function updateCounters(liked, commented, skipped, failed) {\n        counters.innerHTML = `\n            <div class=\"counter-item liked\">\n                <span class=\"counter-label\">Liked:</span>\n                <span class=\"counter-value\">${liked}</span>\n            </div>\n            <div class=\"counter-item commented\">\n                <span class=\"counter-label\">Commented:</span>\n                <span class=\"counter-value\">${commented}</span>\n            </div>\n            <div class=\"counter-item skipped\">\n                <span class=\"counter-label\">Skipped:</span>\n                <span class=\"counter-value\">${skipped}</span>\n            </div>\n            <div class=\"counter-item failed\">\n                <span class=\"counter-label\">Failed:</span>\n                <span class=\"counter-value\">${failed}</span>\n            </div>\n        `;\n    }\n\n    function updateCurrentUrl(url) {\n        if (url) {\n            currentUrlDisplay.innerHTML = `\n                <strong>Current:</strong>\n                <span class=\"current-url-link\" title=\"${url}\">${url.length > 60 ? url.substring(0, 60) + '...' : url}</span>\n                <span class=\"open-icon\">🔗</span>\n            `;\n            currentUrlDisplay.style.display = 'block';\n        } else {\n            currentUrlDisplay.style.display = 'none';\n        }\n    }\n\n    function openCurrentUrl() {\n        if (automationState && automationState.currentUrl) {\n            chrome.tabs.create({ url: automationState.currentUrl });\n        }\n    }\n\n    function addLogEntry(message, type = 'info', store = true) {\n        const timestamp = new Date().toLocaleTimeString();\n        const logEntry = {\n            message,\n            type,\n            timestamp: new Date(),\n            timestampStr: timestamp\n        };\n\n        if (store) {\n            allLogs.push(logEntry);\n        }\n\n        // Apply filter\n        if (logFilter === 'all' || logFilter === type) {\n            displayLogEntry(logEntry);\n        }\n    }\n\n    function displayLogEntry(logEntry) {\n        const logElement = document.createElement('div');\n        logElement.className = `log-entry log-${logEntry.type}`;\n        logElement.innerHTML = `\n            <span class=\"log-timestamp\">[${logEntry.timestampStr}]</span>\n            <span class=\"log-message\">${logEntry.message}</span>\n        `;\n        logContent.appendChild(logElement);\n        logContent.scrollTop = logContent.scrollHeight;\n    }\n\n    function setLogFilter(filter) {\n        logFilter = filter;\n        \n        // Update button states\n        document.querySelectorAll('.filter-btn').forEach(btn => {\n            btn.classList.toggle('active', btn.dataset.filter === filter);\n        });\n\n        // Re-render logs\n        logContent.innerHTML = '';\n        allLogs.forEach(log => {\n            if (filter === 'all' || filter === log.type) {\n                displayLogEntry(log);\n            }\n        });\n    }\n\n    function clearLogs() {\n        allLogs = [];\n        logContent.innerHTML = '';\n        addLogEntry('Logs cleared', 'info');\n    }\n\n    function exportLogs() {\n        if (allLogs.length === 0) {\n            addLogEntry('No logs to export', 'warning');\n            return;\n        }\n\n        // Export as CSV\n        const csvContent = [\n            'Timestamp,Type,Message',\n            ...allLogs.map(log => `\"${log.timestamp.toISOString()}\",\"${log.type}\",\"${log.message.replace(/\"/g, '\"\"')}\"`)\n        ].join('\\n');\n\n        downloadCSV(csvContent, `linkedin-automation-logs-${Date.now()}.csv`);\n        addLogEntry('Logs exported to CSV', 'success');\n    }\n\n    function downloadCSV(content, filename) {\n        const blob = new Blob([content], { type: 'text/csv' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        a.click();\n        URL.revokeObjectURL(url);\n    }\n\n    function downloadJSON(data, filename) {\n        const content = JSON.stringify(data, null, 2);\n        const blob = new Blob([content], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        a.click();\n        URL.revokeObjectURL(url);\n    }\n\n    // Listen for messages from background script\n    chrome.runtime.onMessage.addListener(function(message) {\n        switch (message.action) {\n            case 'updateProgress':\n                currentIndex = message.index;\n                automationState = message.state;\n                updateProgress(message.state.stats);\n                updateCurrentUrl(message.state.currentUrl);\n                updateStatus(`Processing ${currentIndex + 1}/${currentUrls.length} posts`, 'running');\n                break;\n\n            case 'postProcessed':\n                const { url, status: postStatus, liked, commented, skipped, error, errorCode } = message;\n                let logMessage = `Post ${currentIndex + 1}: ${postStatus}`;\n                let logType = 'info';\n\n                if (error) {\n                    logMessage += ` (${errorCode || 'ERROR'})`;\n                    logType = 'error';\n                } else if (skipped) {\n                    logType = 'warning';\n                } else if (liked || commented) {\n                    logType = 'success';\n                }\n\n                addLogEntry(logMessage, logType);\n                break;\n\n            case 'automationComplete':\n                resetUI();\n                updateStatus('Automation completed successfully!', 'idle');\n                addLogEntry('Automation completed successfully!', 'success');\n                if (message.stats) {\n                    addLogEntry(`Final stats: ${message.stats.liked} liked, ${message.stats.commented} commented, ${message.stats.skipped} skipped, ${message.stats.failed} failed`, 'info');\n                }\n                break;\n\n            case 'automationError':\n                resetUI();\n                updateStatus(`Error: ${message.error}`, 'error');\n                addLogEntry(`Automation error: ${message.error}`, 'error');\n                break;\n\n            case 'logMessage':\n                addLogEntry(message.message, message.type || 'info');\n                break;\n\n            case 'urlTimeout':\n                addLogEntry(`URL timeout: ${message.url} (${message.timeout}s)`, 'error');\n                break;\n\n            case 'retryAttempt':\n                addLogEntry(`Retry attempt ${message.attempt}/${message.maxRetries} for URL: ${message.url}`, 'warning');\n                break;\n        }\n    });\n});","size_bytes":20293}},"version":1}